---
sticker: emoji//1f5a5-fe0f
---
# 计算机组成

计算机的组成部件可以分为三大类：**中央处理单元(CPU)**、**主存储器** 和 **输入/输出子系统**

![[assets/images/Pasted image 20240621152439.png|900]]

## 中央处理单元

中央处理单元用于数据运算。它有三个组成部分：**算术逻辑单元**、**控制单元**、**寄存器组**

![[assets/images/Pasted image 20240621152622.png|900]]

**算术逻辑单元** 对数据进行逻辑、移位和算术运算。参考 [[数据运算]] 中的介绍

**寄存器** 是临时存放数据的高速独立存储单元。CPU 的运算离不开大量寄存器的使用
+ **数据寄存器**：存储输入数据和运算结果
+ **指令寄存器(IR)**：存储程序的指令。CPU 主要职责：从内存中逐条取出指令，并将取出的指令存储到 **指令寄存器**
+ **程序计数器(PC)**：保存着当前正在执行的指令所在内存的地址。当指令执行完成后，计数器将自动加 $1$，执行下一条指令的内存地址

**控制单元** 控制各个子系统的操作。控制是通过从控制单元到其他子系统的信号进行

## 主存储器

**主存储器** 是存储单元的集合，每一个存储单元都有唯一的标识，称为 **地址**。数据以称为 **字** 的位组的形式在内存中 **传入** 和 **传出**。字可以是 $8$ 位、$16$ 位、$32$ 位、$64$ 位
+ $8$ 位，称为 $1$ 字节
+ $16$ 位，称为 $2$ 字节
+ $32$ 位，称为 $4$ 字节

![[assets/images/Pasted image 20240621153546.png|900]]

在存储器中存取每个字都需要相应的标识符。程序员使用名字来区分字，但是在硬件层次上，**每个字都是通过地址来标识的**。所有在存储器中 **标识的独立的地址单元** 的总数称为 **地址空间**

下表列出来常用于表示存储大小的单位名称

![[assets/images/Pasted image 20240621153900.png|900]]

由于计算机都是以位模式存储数据并计算的，因此 **地址本身也是用位模式表示的**。

> [!important] **内存地址使用无符号二进制整数表示**

现代计算机中，**最小的寻址单位是字节**。对于多字节对象，必须建立两个规则：**对象的地址是什么**？以及 **在内存中如何排列这些字节**

> [!tip] 多字节对象的地址
> 
> 在几乎所有的机器上，多字节对象都被存储为 _连续的字节序列_，对象的 _地址_ 为所使用字节中的 _最小地址_

> [!tip] 最高有效字节和最低有效字节
> 
> 假设一个 $w$ 为的整数，其位模式为 $[x_{w-1},x_{w-2}, \cdots., x_{1}, x_{0}]$，其中 $x_{w-1}$ 是 **最高有效位**；$x_0$ 是 **最低有效位**
> 
> 假设 $w=8\cdots k$ 其中 $k=1,2,\cdots$，这些为就能分组成为字节，其中 **最高有效字节** 包含 $[x_{w-1},x_{w-2},\cdots,x_{w-8}]$；**最低有效字节** 包含 $[x_{7},x_{6}, \cdots,x_{0}]$
> 


> [!tip] 在内存中如何排序多字节对象
> 
> 
> 某些机器（采用 **小端法**）在内存中按照 **从最低有效字节到最高有效字节的顺序** 存储对象
> 
> 另一些机器则（采用 **大端法**）在内存中按照 **从最高有效字节到最低有效字节的顺序** 存储对象
> 
> 假设变量 $x$ 的类型为 `int`，位于地址 `0x100` 处，它的十六进制值为 `0x01234567`。地址范围 `0x100 ~ 0x103` 的字节序依赖于机器的类型
> 
> ![[Pasted image 20240910155358.png]]

### 存储器类型

主要有两种类型的存储器：RAM 和 ROM

**随机存取存储器(RAM)** 是计算机中 **主存的主要组成部分**。主要特点就是 **易失性**，系统断电，信息将丢失。主要分为两大类：SRAM 和 DRAM
+ **静态RAM(SRAM)** 技术是用传统的 **触发器门电路** 来保存数据。这些门保持状态(0或1)，也就是说当 **通电的时候数据始终存在**，**不需要刷新**。SRAM **速度快**，但是 **价格昂贵**
+ **动态RAM(DRAM)** 技术使用 **电容器**。如果电容器**充电**，则这时的状态是 $1$ ；如果**放电**则状态是 $0$。因为电容器会 **随时间而漏掉一部分电**，所以内存单元需要 **周期性地刷新**。DRAM **比较慢**，但是 **比较便宜**

**只读存储器(ROM)** 的内容是由制造商写进去的。用户 **只能读** 但不能写，它的优点是 **非易失性**，当切断电源后，数据也不会丢失。通常 **用来存储那些关机后也不能丢失的程序或数据**。例如，用 ROM 来存储那些在开机时运行的程序。

### 存储器层次结构

计算机用户 **需要许多存储器**，尤其是 **速度快且价格低廉的存储器**。但这种要求并不总能得到满足。**存取速度快的存储器通常都不便宜**。因此能要寻找一种折中的办法。解决的办法是采用存储器的层次结构

![[assets/images/Pasted image 20240621154717.png|900]]

**当对速度要求很苛刻时可以使用少高速存储器**。CPU 中的寄存器就是这种存储器。

**用适量的中速存储器来存储经常需要访问的数据**。例如，**高速缓冲存储器**

**大量的低速存储器存储那些不经常访问的数据**，例如，**主存** 就属于这一类

### 高速缓冲存储器

**高速缓中存储器** 的存取 **速度要比主存快**，但是比 CPU 及其内部的寄存器要慢。高速缓冲存储然 **通常容量较小**，且常被 **置于 CPU 和主存之间**

![[assets/images/Pasted image 20240621155032.png|900]]

高速缓冲存储器在任何时间都**含有主存中一部分内容的副本**。当 CPU 要存取主存中的一个字的时候，将按以下步骤进行
+ CPU 首先检查高速缓冲存储器
+ 如果要存取的字存在，CPU 将它复制到寄存器中；如果不存在，CPU 将从主存储中复制一份从需要读取的字开始的数据库。该数据块会覆盖高速缓冲存储器中的内容
+ CPU 存储高速缓冲存储器并复制该字

这种方式将提高运算的速度；如果字在高速缓冲存储器中，就立即存取它。如果字不在高速缓冲存储器中，字和整个数据块就会被复制到高速缓冲存储器中。因为很有可能 CPU 在下次存取中需要存取上次存取的第一个字的后续字（**局部性**），所以高速缓冲存储器可以大大提高处理的速度

## 输入/输出子系统

计算机中的第三个子系统是称为 **输入/输出(I/O)子系统** 的一系列设备。这个于系统可以**使计算机与外界通信**，并 **在断电的情况下存储程序和数据**。输入/输出设备可以分为两大类：**非存储设备** 和 **存储设备**

### 非存储设备

**非存储设备** 使得 CPU 和内存可以与外界通信，但它们不能存储信息

**键盘** 和 **显示器** 是两个最常见的非存储输入/输出设备。键盘提供输入能力；显示器输出并同时响应键盘的输入

**打印机** 是一种用于产生永久性记录的输出设备。它是非存储设备，因为要打印的材料不能直接由打印机输入计算机中，而且也不能再次利用

### 存储设备

尽管 **存储设备** 被分为输入/输山设备，但它 **可以存储大量的信息以备后用**。它们要比主存便宜得多，而且存储的信息也 **不易丢失**(即使断电信息也不会丢失)。有时称它们为 **辅助存储设备**，通常分为 **磁介质** 和 **光介质** 两种

#### 磁介质存储设备

磁介质存储设备使用 **磁性** 来存储位数据。如果一点 **有磁性则表示 $1$**，如果 **没有磁性则表示 $0$**

**磁盘** 是由一张一张的 **磁片叠加而成的**。这些 磁片有两面或者称为 **表面(Surface)**，**由薄磁膜封装** 起来。信息是通过盘上每一个磁片的 **读/写磁头** 读写磁介质表面来进行读取和存储的

![[assets/images/Pasted image 20240621161059.png|900]]

**表面结构**：为了将数据存储在磁盘的表面，每个盘面都被划分成 **磁道(Tracks)**，每个磁道又分成若干个 **扇区(Sectors)**。磁道之间通过磁道间的 **间隔** 隔开，扇区之间通过扇区间的 **间隔(Gaps)** 隔开

**数据存取**：磁盘是一个 **随机存取设备**。在随机存取设备中，数据项可以被随机存取，而不需要存取放置在其前的所有其他数据。但是，**在某一时间可以读取的最小的存储区域只能是一个 _扇区_**。数据块可以存储在一个或多个扇区上，而且该信息的获取不需要通过读取磁盘上的其他信息。

**性能**：磁盘的性能取决于几个因素最重要的因素是 **角速度**、**寻道时间** 和 **传送时间**
+ **角速度** 定义了 **磁盘的旋转速度**
+ **寻道时间** 定义了读/写磁头 **寻找数据所在磁道的时间**
+ **传送时间** 定义了将 **数据从磁盘移到CPU/内存所需要的时间**

## 子系统的互联

### CPU 和 存储器的连接

CPU和存储器之间通常由称为 **总线** 的三组线路连接在一起，它们分别是 **数据总线**、**地址总线** 和 **控制总线**

![[assets/images/Pasted image 20240621162022.png|900]]

**数据总线** 是由多根线组成，**每一根线上每次传送$1$ 位的数据**。线的数量取决于计算机的字的大小。例如，计算机的字是 $32$ 位($4$ 字节)，那么需要有 $32$ 根线的数据总线，以便同一时刻能够同时传送 $32$ 位的字。 ^537218

**地址总线** 允许 **访问存储器中的某个字**，地址总线的线数取决于存储空间的大小。如果存储器容量为 $2^n$ 个字，那么地址总线一次需要传送 $n$ 位的地址数据。因此它需要 $n$ 根线 ^3fe3bd

**控制总线** 负责在中央处理器和内存之间传送信息。必须有一个代码从 CPU 发往内存，用于指定进行的是读操作还是写操作。**控制总线的线数取决于计算机所需要的控制命令的总数**。如果计算机有 $2^m$ 条控制命令，那么控制总线就需要有 $m$ 根，因为 $m$ 位可以定义 $2^m$ 个不同的操作

### IO设备的连接

**输入/输出设备不能够直接与连接 CPU 和内存的总线相连**。因为输入/输出设备的本质与CPU和内存的本质不同，输入/输出设备都是些机电、磁性或光学设备，而CPU和内存是电子设备。**与CPU和内存相比，输入/输出设备的操作速度要慢得多**。因此必须要有 **中介** 来处理这种差异，输入/输出设备是通过一种被称为 **输入/输出控制器或接口** 的器件连接到总线上的。**每一个输入/输出设备都有一个特定的控制器**

![[assets/images/Pasted image 20240621162703.png|900]]

**控制器**，或者说 **接口**，**消除了输入/输出设备与CPU及内存在本质上的障碍**。控制器可以是 **串行或并行** 的设备
+ 串行控制器则只有一根数据线连接到设备上
+ 并行控制器则有数根数据线连接到设备上，使得一次能同时传送多个位

有几种控制器至今还在使用，如今最常用的有 SCSI、火线、USB 和 HDMl

**小型计算机系统接口(SCSI)** 是一个 $8$、$16$ 或 $32$ 线的 **并行接口**。它提供了 **菊花链连接**，连接链的 **两端都必须有终结器**，并且 **每个设备都必须要有唯一的地址**

![[assets/images/Pasted image 20240621163142.png|900]]

**火线** 是一种高速的 **串行接口**，**数据采用数据包的形式传送**，数据的传输速度高达到 50MB/s。它可以在一条菊花链或树形连接(只用一根线)上连接多达 $63$ 个设备，它不需要终结器

![[assets/images/Pasted image 20240621163327.png|900]]

**通用串行总线(USB)** 是一种 **串行控制器**，用以 **连接与计算机相连的一些低速和高速设备**。多个设备可以被连接到一个 USB 控制器上，这个控制器也称为 **根集线器**。允许多达127个设备组成树状拓扑结构连接到一个USB控制器上，其中控制器作为树的根，**集线器** 作为中间节点，设备作为末端节点

![[assets/images/Pasted image 20240621163554.png|900]]

### IO设备的寻址

CPU使用 **相同的总线** 在主存和输入/输出设备之间读写数据。**唯一的不同是指令**。如果指令涉及主存中的字，那么数据会在主存和CPU之间传送。如果指令涉及输入/输出设备，那么数据会在输入/输出设备和 CPU 之间传送。有两种方法用来对输入/输出设备进行寻址，即 **I/O独立寻址** 和 **I/O 存储器映射寻址**

**I/O独立寻址**：读写内存和I/O设备的指令完全不同

![[assets/images/Pasted image 20240621163931.png|900]]

> [!info] 因为指令的不同，所以输入/输出地址可以和内存地址重叠而不会产生混淆

**I/O 存储器映射寻址**：CPU 将I/O设备中的寄存器看作内存中的某个存储字

![[assets/images/Pasted image 20240621163945.png|900]]

> [!info] 存储器映射的输入/输出的配置 **优点在于有一个较小的指令集**，所有对内存的操作指令都同样适合于输入/输出设备，其 **缺点是输入/输出控制器占用了一部分内存地址**

## 程序执行

当今，通用计算机使用称为程序的一系列指令来处理数据。计算机通过执行程序，将输入数据转换成输出数据。程序和数据都放在内存中。

### 机器周期

CPU 利用重复的机器周期来执行程序中的指令，一步一条，从开始到结束。一个简化的周期包括 $3$ 步：**取指令**、**译码** 和 **执行**

![[assets/images/Pasted image 20240621164311.png|900]]

**取指令阶段**：控制单元命令系统将下一条将要执行的 **指令复制到CPU的指令寄存器(IR)** 中。被复制的指令地址保存在程序计数器中。**复制完成后，程序计数器自动加 $1$ 指向内存中的下一条指令**

**译码阶段**：当指令置于指令寄存器后，该指令将 **由控制单元负责译码**。指令译码的结果是 **产生一系列系统可以执行的二进制代码**

**执行阶段**：指令译码完毕后，**控制单元发送任务命令到CPU的某个部件**，例如，控制单元告知系统，让它 **从内存中加载(读)数据项**，或者是 CPU 让算术逻辑单元将两个输入寄存器中的内容相加并将结果保存在输出寄存器

### IO操作

计算机需要通过命令 **把数据从 IO设备传输到 CPU 和内存**。因为输入/输出设备的运行速度比CPU 慢得多，因此 **CPU 的操作在某种程度上必须和输入/输出设备同步**，有三种方法被设计用于同步，分别为: **程序控制IO**、**中断控制IO**、**直接存储器存取(DMA)**

**程序控制IO**，采用最简单的一种同步：**CPU等待IO设备**。**当 CPU 遇到一条 lO 指令时，它就停止工作直到数据传输完毕**。CPU 不时地查询 IO 设备的状态
+ 如果设备做好了传输准备，那么数据将被传送到CPU
+ 如果设备没有做好传输准备，那么 CPU 将继续查询IO设备的状态直到IO设备准备好为止

![[assets/images/Pasted image 20240621165217.png|900]]

> [!question] **程序控制IO：CPU 等待 IO 完成**
> + 当每一个单元数据被传输时，CPU 都要浪费时间去查询 IO 状态


**中断控制IO**：首先 CPU 告知 I/O 设备即将开始传输，但是 CPU 并不需要不停地查询 I/O 设备的状态。当 I/O 设备准备好时，它通知(中断)CPU

![[assets/images/Pasted image 20240621165354.png|900]]
> [!hint] **中断控制IO：CPU 不等待 IO 完成**
> + CPU 通知 I/O 设备后，不等待 IO 完成，转而执行其他操作
> + I/O 设备准备好数据后，发送中断信号给 CPU，通过 CPU 数据准备完成
> 
> **整个过程 CPU 都处于工作状态**

**直接存储器存取(DMA)** ：用于在高速 I/O 设备间传输大量的数据块。例如，磁盘、内存(不需要通过CPU的数据传输)。使用 DMA 控制器来承担 CPU 的部分功能

![[assets/images/Pasted image 20240621165744.png|900]]

CPU 发送信息给 DMA。这些消息包括传输类型(输入或输出)、内存单元的起始地址以及传输的字节数。之后 CPU 就可做其他的工作。当准备好传输数据时，则由DMA控制器通知 CPU 它需要获得总线的使用权。这时 CPU 停止使用总线并转交给 DMA 控制器使用。在内存和DMA 间的数据传输完成后，CPU继续进行正常操作

![[assets/images/Pasted image 20240621170029.png|900]]

需要注意的是，在这种方法中，CPU 只是在一小段时间内是空闲的。CPU 仅当在 DMA 和内存间传输数据时才空闲，而不是在设备为传输数据做准备时

> [!hint] **直接存储器存取：需要 DMA 控制器承担一部分 CPU 的功能**
> + CPU 通知 DMA 需要进行的操作。之后，CPU 就执行其他操作
> + DMA 准备数据传输，数据准备完成后，中断 CPU，并获得总线控制权
> + CPU 等待 DMA 数据的数据传输完成
> + DMA 再次中断 CPU，通过 CPU 数据传输完成
>   
>  CPU 会在 DMA 和 主存直接进行数据传送时暂停工作

## 流水线

每条指令使用**取指令**、**译码**和 **执行** 三个阶段。在早期计算机中，每条指令的这三个阶段需要串行完成。换言之，指令 $n$ 需要在指令 $n+1$ 开始它的阶段之前完成它的所有阶段

现代计算机使用称为 **流水线** 的技术来改善吞吐量(在单位时间内完成的指令总数)。这个理念是如果 **控制单元能同时执行两个或三个阶段**，那么 **下一条指令就可以在前一条指令完成前开始**

![[assets/images/Pasted image 20240621170820.png|900]]

## 简单计算机：模拟程序执行流程

为了解释计算机的体系结构王有它们的指令处理，我们引入一台简单(非真实的)计算机。简单计算机有三个组成部分 **CPU**、**存储器** 和 **输入/输出子系统**。

![[assets/images/Pasted image 20240621171018.png|900]]

### CPU

CPU 本身被分成三部分：**数据寄存器**、**算术逻辑单元(ALU)** 和 **控制单元**

+ **数据寄存器**：简单计算机有 $16$ 个 $16$ 的数据寄存器，编号为 $R_{0} \sim R_{15}$
+ **控制单元**：两个专用寄存器 **程序计数器(PC)** 和 **指令寄存器 IR**

### 主存

主存有 $256$ 个 $16$ 位的存储单元，二进制的地址为 $(00000000)_{2}$，到 $(11111101)_{2}$ 或者是 十六进制的 $(00)_{{16}}$ 到 $(FD)_{16}$ 。主存中 **既有数据，又有程序指令**
+ 前 $64$ 个存储单元 $(00)_{16}$到 $(3F)_{16}$ 被专用于程序指令。任何程序的程序指令存储在连续的内存单元中
+ 存储单元 $(40)_{{16}}$ 到 $(FD)_{16}$ 被用来存储数据

### 输入/输出子系统

简单计算机有一个非常原始的输入/输出子系统。子系统由一个**键盘**和一台 **显示器** 组成。它们 **采用 IO 存储器映射寻址**。它们的地址分别为 $(FE)_{16}$ 和 $(FF)_{{16}}$

### 指令集

简单计算机具有 $16$ 条指令集合的能力。每条计算机指令由两部分构成，**操作码(opcode)** 和 **操作数(operand)**。操作码指明了在操作数上执行的操作的类型

每条指令由 $16$ 位组成，被分成 $4$ 个 $4$ 位的域。最左边的域含有操作码，其他 $3$ 个域含有操作数或操作数的地址

![[assets/images/Pasted image 20240621172113.png|900]]

指令列在表中。注意，并不是每条指令都需要 $3$ 个操作数。任何不需要的操作数域被填以 $(0)_{{16}}$ 。例如，停机指令的所有 $3$ 个操作数域、传送指令和 NOT 指令的最后一个域都被填以 $(0)_{{16}}$ 。还要注意，寄存器地址是用单个十六进制数来表示的，所以只用一个域，而内存单元是用两个十六进制数来表示，所以用两个域

![[assets/images/Pasted image 20240621172440.png|900]]

### 处理指令

简单计算机 **使用机器周期**。一个周期有三个阶段：**取指令**、**译码** 和 **执行**
+ 在取指令阶段，其地址由 PC 决定的指令从内存中得到，被装入lR中。然后 PC 加 1，指向下一条指令
+ 在译码阶段，IR中的指令被译码，所需的操作数从寄存器或内存中取到
+ 在执行阶段，指令被执行，结果被放入合适的内存单元或寄存器中

一旦第三阶段结束，控制单元又开始新的周期，现在 PC 是指向下一条指令的。处理过程一直继续，直到 CPU 遇到 HALT 指令

### 存储程序和数据

为了遵循冯诺依曼模型，我们需要把程序和数据存储在内存中，可以从内存单元 $(00)_{{16}}$ 到 $(04)_{{16}}$ 存储 $5$ 行程序。我们已经知道数据也需要被存储在内存单元 $(40)_{{16}}$  $(41)_{16}$ 和 $(42)_{{16}}$ 中

### 指令周期

**计算机每条指令使用一个指令周期**。如果有 $5$ 条指令的小程序，那么需要 $5$ 个指令周期。每个周期通常由三个步骤组成：**取指令**、**译码**、**执行**

现在假定需要相加 $161+ 254 = 415$。这些数据在内存中用十六进制表示为 $(OOA1)_{16}$  $(OOFE)_{16}$  和$(OO19F)_{16}$ 


在 **第一周期** 开始时，PC指向程序的第一条指令，它在内存单元 $(00)_{16}$ 中。控制单元经历如下三个步骤
+ 控制单元取出存储内存单元 $(00)_{16}$ 中的指令，放入 IR 中，PC 的值加1
+ 控制单元译码指令 $(1040)_{16}$ 。$(1040)_{16} = 0001\ 0000\ 0100\ 0000$ `LOAD RO M[40]`
+ 控制单元执行指令。意味着存储在内存单元 $(40)_{16}$ 中的整数的副本被装入寄存器 $R_0$ 中

![[assets/images/Pasted image 20240621185655.png|900]]

在 **第二周期** 开始时，PC指向程序的第二条指令，它在内存单元 $(01)_{16}$ 中。控制单元经历如下三个步骤，
+ 控制单元取出存储在内存单元  $(01)_{16}$  中的指今，放入 IR 中，PC 的值加 1
+ 控制单元译码指令 $(1141)_{16}$ 。$(1141)_{16} = 0001\ 0001\ 0100\ 0001$ `LOAD R1 M[41]`
+ 控制单元执行指令，这意味着存储在内存单元 $(41)_{16}$ 中的整数的副本被装入寄存器 $R_1$ 中

![[assets/images/Pasted image 20240621185240.png|900]]

在 **第三周期** 开始时，PC 指向程序的第三条指令，它在内存单元 $(02)_{16}$ 中。控制单元经历如下三个步骤
+ 控制单元取出存储在内存单元 $(02)_{16}$  中的指今，放入 IR 中，PC 的值加 1
+ 控制单元译码指令 $(3201)_{16}$ 。$(3201)_{16} = 0011\ 0010\ 0000\ 0001$ `ADDI R2 RO R1`
+ 控制单元执行指令，这意味着寄存器 $R_0$ 中的内容被加到寄存器 $R_{1}$ 中的内容(在 ALU 中完成)，结构存储到 $R_2$ 中

![[assets/images/Pasted image 20240621185755.png|900]]

在 **第四周期** 开始时，PC 指向程序的第四条指令，它在内存单元 $(03)_{16}$ 中。控制单元经历如下三个步骤
+ 控制单元取出存储在内存单元 $(03)_{16}$  中的指今，放入 IR 中，PC 的值加 1
+ 控制单元译码指令 $(2422)_{16}$ 。$(2422)_{16} = 0010\ 0100\ 0010\ 0010$ `STORE R2 M[42]`
+ 控制单元执行指令，这意味着寄存器 $R_0$ 中的内容被加到寄存器 $R_{1}$ 中的内容(在 ALU 中完成)，结构存储到 $R_2$ 中

![[assets/images/Pasted image 20240621190239.png|900]]

在 **第五周期** 开始时，PC 指向程序的第五条指令，它在内存单元 $(04)_{16}$ 中。控制单元经历如下三个步骤
+ 控制单元取出存储在内存单元 $(04)_{16}$  中的指今，放入 IR 中，PC 的值加 1
+ 控制单元译码指令 $(0000)_{16}$ 。$(0000)_{16} = 0000\ 0000\ 0000\ 0000$ `HALT`
+ 控制单元执行指令，这意味着计算机停止工作
