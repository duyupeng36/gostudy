---
sticker: emoji//2795
---
# 数据运算

## 逻辑运算

**逻辑运算** 是指那些应用于 *模式* 中的 **一个二进制位**，或在 *两个模式* 中 **相应的两个二进制位的相同基本运算**
- 这意味着我们可以在 *位层次上* 和 *模式层次上* 定义逻辑运算

一个位可能是 $0$ 或 $1$ ，可以假设 $0$ 代表逻辑 “假”，而 $1$ 代表逻辑“真”：**位层次上** 的运算有下列四种
- **非(`NOT`)**: 只需要一个输入，输出内容为输入的反转。`NOT`运算符是一元操作符:它只有一个输如。输出位是输入位的相反，
	- 如果输入是 $0$，则输出为 $1$
	- 如果输入为 $1$，则输出为 $0$
	- 换言之，`NOT` 运算符是 **将输入的反转**
- **与(`AND`)**: 需要两个输入，如果输入都是 $1$，则输出为 $1$；否则输出为 $0$（有 $0$ 则 $0$）
- **或(`OR`)**: 需要两个输入，如果输入有 $1$，则输出为 $1$，否则输出为 $0$ (有 $1$ 则 $1$)
- **异或(`XOR`)**: 需要两个输入，当输入相同时，则输出为 $0$; 当输入不同时，则输出为 $1$ (相同则 $0$，不同则 $1$)

![[assets/images/Pasted image 20240621150831.png|900]]

**模式层次上** 的逻辑运算是具有相同类型的位层次上的 $n$ 次逻辑运算，这里的 $n$ 就是模式中的位的数目


## 移位运算

移位运算移动位模式中的位，改变位的位置。它们能向左或向右移动位。我们可以把移位运算分成两大类: **逻辑移位运算** 和 **算术移位运算**
### 逻辑移位运算

逻辑移位运算有两种：**逻辑右移** 和 **逻辑左移**
- **逻辑右移运算**: 把每一位向右移动一个位置。在 $n$ 位模式中，最右位丢失，最左位填 $0$
- **逻辑左移运算**: 把每一位向左移动一个位置。在 $n$ 位模式中，最左位丢失，最右位填 $0$

![[assets/images/Pasted image 20240621151032.png|900]]

### 循环移位

循环移位是逻辑移位的一种，移动过程中没有丢弃或者增加，同样有两种运算：**循环右移** 和 **循环左移**
- **循环右移(右旋转)**: 把每一位向右移动一个位置,最右位被回环, 成为最左位
- **循环左移(左旋转)**: 把每一位向左移动一个位置,最左位被回环, 成为最右位

![[assets/images/Pasted image 20240621151115.png|900]]

### 算术移位运算

**算术移位运算** 假定位模式是用二进制补码格式表示的带符号位的整数，也分为两种运算符
：**算术右移** 和 **算术左移**
- **算术右移**: 如果移动一位，就是对整数除以 $2$；**保留符号位,但同时也把它复制，放入相邻的右边的位中**
- **算术左移**: 如果移动一位，就是对整数乘以 $2$；**丢弃符号位，接受它的左边的位作为符号位**

如果新的符号位与原先的相同，那么运算成功，否则发生上溢或下溢，结果是非法的

![[assets/images/Pasted image 20240621151130.png|900]]

**左移无论是算术移位还是逻辑移位都是一样的**，只有右移才需要区分算术移位和逻辑移位


## 算术运算
 
**算术运算** 包括加、减、乘、除；适用于整数和浮点数。这里，我们只介绍 **二进制补码的加减法**
### 二进制补码的加减法

整数通常是以二进制补码形式存储的。**二进制补码表示法的一个优点是加法和减法间没有区别**。当遇到减法时，计算机只简单地把它转变为加法，但要为第二个数求二进制的补。 二进制补码加减法的计算过程如下图

![[assets/images/Pasted image 20240621151303.png|900]]

过程如下:
- 如果运算是**减法**，我们 **取第二个整数的二进制补码**，否则，转下一步 
- 两个整数相加
