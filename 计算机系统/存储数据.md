---
sticker: emoji//1f4be
---
# 存储数据

数据以不同的形式出现：**数字**、**文本**、**音频**、**图像** 和 **视频**。人们需要能够处理许多不同的数据类型

![[assets/images/Pasted image 20240621132839.png|900]]

所有计算机外部的数据类型的数据都采用 **统一的数据表示法** 转换后存入计算机中，当数据从计算机输出时再还原回来。这种通用的格式称为 **位模式**。位模式是由 **位** 组成的序列

位是存储在计算机中最小的单位；它是 $0$ 或 $1$。代表设备的某一状态，这些设备只能处于两种状态之一

> [!hint] **位** 代表了设备的某一状态
> **开关** 就是一个很好的例子
> - $0$ 代表 **断开** 状态
> - $1$ 代表 **合上** 状态

**位模式** 是一些位组成的 **位序列**，也称 **位流**。长度为 $0$ 的位模式被称为 $1$ 字节

属于不同数据类型的数据可以采用相同的位模式存储在存储器中

![[assets/images/Pasted image 20240621133702.png|900]]

> [!important] 相同的位模使用不同的处理程序表示的数据可能完全不同
> 如果使用文本编辑器(文字处理器)，键盘上的字符 `"A"` 可以以 $8$ 位模式 `01000001` 存储
> 
> 如果使用数学程序，同样的 $8$ 位模式可以表示数字 $65$ 
> 
> 类似地，同样的位模式可表示部分图像、部分歌曲、影片中的部分场景
> 
> **计算机内存存储所有这些而无需辨别它们表示的是何种数据类型**

## 存储数字

在存储到计算机内存之前，数字被转换到二进制系统

> [!question] 还需要解决下面两个问题
> + 如何存储数字的符号
> + 如何表示十进制小数点

### 存储整数

整数是完整的数字，即没有小数点。例如，$134$ 和 $-125$ 是整数，而 $134.23$ 和 $-0.235$ 则不是

**整数** 可以看做 **小数点固定在最右边的数字**。对应这种小数点固定的数字，采用 **定点表示法**。这种表示法中，小数点是假定的，并不存储

![[assets/images/Pasted image 20240621134433.png|900]]

> [!warning] 整数作为小数部分为 $0$ 的浮点表示也可能的
> + 整数太大以至于无法定义为整数来存储

为了更有效地利用计算机内存，无符号和有符号的整数在计算机中存储方式是不同的

#### 无符号表示法

**无符号整数** 是只包括 $0$ 和正数的非负整数。介于 $0$ 到 $\infty$ 之间。由于计算机存储资源限制，通过定义一个常量，称为 **最大无符号整数**，它的值为 $2^{n}-1$，这里 $n$ 就是计算机中分配用于表示无符号整数的 **位模式长度(二进制位数)**

##### 存储

为了将整数存储到计算机中，输入设备将 **输入的整数变成二进制数**
+ 如果二进制 **位数不足 $n$ 位**，则在 **左边使用 $0$ 补齐 $n$ 位**
+ 如果 **位数大于 $n$ 位**，则 **无法存储** 该整数，导致溢出

例如，将 $7$ 存储在 $8$ 位存储单元中，使用无符号表示法

```
将 7 转换为二进制表示      -->        111
在最左边使用 0 补齐到 8 位 ---> 0000 0111
```

输出设备输出整数时，需要 **译解内存中位模式** 的位串转换为一个十进制的无符号整数

##### 溢出

因为存储单元的位的数量限制，可以表达的整数范围有限。在 $n$ 位存储单元中，可以存储的无符号整数范围为 $0 \sim 2^{n} - 1$。下图，展示 $4$ 位内存中存储大于 $2^4 - 1=15$ 的整数时发生的情形

![[assets/images/Pasted image 20240621135926.png|900]]

整数 $11$ 在存储单元中，当它加上 $9$ 后就发生了溢出。表示十进制数 $20$ 的最小位数是 $5$，即 $20 = (10100)_{2}$，所以计算机丢掉最左边的位，保留最右边的 $4$ 位 $(0100)_{2}$

##### 应用

无符号整数表示法可以提供存储器的效率，因为不需要存储符号。分配的位单元可以全部用来存储数字。只要不使用负数，都可以用到无符号整数表示法
+ 计数
+ 寻址
+ 存储其他数据类型
#### 符号加绝对值表示法(原码)

该表示法将 **最高有效位(最左边的位)用于表示符号**：$0$ 表示 $+$，$1$ 表示 $-$。因此，它将无符号整数的有效范围拆分为两个相等的子范围。如下图，$4$ 位位模式的符号加绝对值表示法的范围

![[assets/images/Pasted image 20240621141001.png|900]]

> [!important] 该表示法中，$0$ 有两种表示方式

这就意味着在一个 $n$ 位存储单元中，可以仅用 $n-1$ 位表示数字的绝对值。因此有效范围为 $[-2^{n-1}-1, 2^{n-1}-1]$ 

##### 溢出

有符号整数也会溢出。但是，存在 **正溢出** 和 **负溢出** 两种情形。下图展示了 $4$ 位内存单元存储一个用符号加绝对值表示的整数时出现正负溢出。

![[assets/images/Pasted image 20240621141432.png|900]]

+ 存储一个比 $7$ 大的数时，出现正溢出
+ 存储一个比 $-7$ 小的数时，出现负溢出

##### 应用

符号加绝对值表示法不用于存储整数，而用于存储其他数据类型，例音频

#### 二进制补码表示法

二进制补码表示法与符号加绝对值表示法最大的不同就是在于最高位的权重。在二进制补码表示法中，最高位的权重为 $-2^{n-1}$。最高位表示符号位，当符号位被置为 $1$ 时，表示值为负；而当设置为 $0$ 时，值为非负

![[assets/images/Pasted image 20240621142122.png|900]]

> [!NOTE] 整数在计算机中采用二进制补码的形式存储
> 
> 根据上述定义，**对于非负整数，无论是无符号表示、符号加绝对值表示法以及二进制补码表示法都是同一个位模式**

如何获将十进制负整数转换为二进制补码表示？

这里我们需要了解两个概念：**补数** 与 **减补数**

> [!important] **补数** 与 **减补数**
> 自然数 $a$ 在给定进制下的 **补数** 定义为：对于给定的 **进制**，与自然数 $a$ 相加后使得得位数增加 $1$ 的最小的数
> 
> + $b$ 进制数 $a$ 关于 **基数的补数** ($b$ 的补数): $b^n−a$
> 
> + $b$ 进制数 $a$ 关于 **减基数的补数** ($b - 1$ 的补数)，简称 **减补数**、侪补数): $b^n-a-1$

对于 $N$ 进制的自然数 $a=a^ra^{r−1}a^{r−2}\cdots a^1a^0$ 规定数 $b$ 的各位为 $b_i=(N+1)+a_i$。称数$b$ 为 $a$ 关于 $N+1$ 的 **补数**

> [!important] 二进制下的 **补数** 与 **减补数**
> 在二进制下，求 $1$ 的补数只需简单地将 $0$ 与 $1$ 相互替换。求 **2补数** (即 **补码**)，只需要将 $1$ 补数加 $1$

所以，为了求一个二进制数的 $2$ 补数，只需要先求 $1$ 补数，然后在加 $1$ 即可

> [!summary] 求十进制负整数的二进制补码表示
> 将该十进制负整数的绝对值转换为二进制表示，然后先对该二进制表示求 $1$ 补数，然后加 $1$ 即可得到该负数的二进制补码表示

例如，对于 $-1$ 采用 $8$ 位位模式表示时，其绝对值 $1$ 的二进制表示为 $00000001$，求 $1$ 补数之后为 $11111110$，在加 $1$ 得到 $11111111$

```
-1 的绝对值 1 的 8 位二进制表示为

0000 0001

其 1 补数为

1111 1110

2补数等于 1补数加1

1111 1111
```

##### 存储

将整数转变为二进制数。如果整数是非负数，则原样存储；如果整数是负数，计算机取其补码存储

将二进制补码还原为整数。如果最高位为 $1$，计算机取其补码。如果是 $0$，则不进行操作

##### 溢出

二进制补码表示法存储整数也会溢出

![[assets/images/Pasted image 20240621143120.png|900]]

### 浮点数

实数是带有整数部分和小数部分的数字。尽管可以使用定点表示，但是结果不一定精确或达不到要求精度。同时，很大的整数部分或很小的小数部分不应该采用定点表达式

浮点数表示法中，无论是十进制还是二进制，一个数字由三部分组成

![[assets/Excalidraw/Drawing 2024-06-21 14.35.48.excalidraw|900]]

为了使表示法定点数部分统一，**小数点左边使用了唯一非零数码**，这称为 **规范化**。规范化之后，只需要存储 **符号**、**指数**、**尾数** 三部分信息即可
+ **符号**采用 $1$ 位存储：$0$ 表示 $+$，$1$ 表示 $-$
+ **指数**：定义了小数点移动的位数，可正可负
+ **尾数**：定义了小数点右边的二进制位数，即该数的精度。采用无符号表示法

**指数** 是有符号数，采用一种称 为**移码系统的表示法**。该表示法将正数和负数都作为无符号数存储。为了表示正的或负的整数，一个正整数(称为**偏移量**)加到每个数字中，将它们统一移到非负的一边。这个 **偏移量的值为 $2^{m-1}-1$，$m$ 为存储指数的位数**

![[assets/images/Pasted image 20240621144709.png|900]]

##### IEEE 标准

IEEE 标准协会定义了几种存储浮点数的标准。下图展示常用的两种

![[Pasted image 20240621144808.png|900]]

> [!important] 约定
> 约定符号、指数、尾数都为 $0$ 时，表示浮点数 $0.0$ 

##### 上溢和下溢

对应浮点数，有上溢和下溢两种情况
+ 试图存储绝对值很小的数时，出现下溢情况
+ 试图存储绝对值很大的数时，出现上溢情况

下图显式使用 $32$ 位内存单元（余 $127$ 码）的浮点表示范围

![[assets/images/Pasted image 20240621145032.png|900]]

## 存储文本

在任何语言中，**文本** 的片段是用来 **表示该语言中某个意思的一系列的符号**

> [!NOTE] 英语中的字符
> 例如，在英语中使用 $26$ 个符号`(A, B, C, ...., Z)`来表示大写字母，26个符号`(a, b, c, ...., z)`表示小写字母，$10$ 个符号`(0, 1, 2, ...., 9)`来表示数字字符(不是实际的数字；后面将看到它们的不同之处)，以及符号 `(. ? :  ; .... !)` 来表示标点。另外一些符号 `(如空格、换行和制表符)` 被用于文本的对齐和可读性

为了在计算机中存储文本，我们 **可用 _位模式_ 来表示任何一个符号**。换句话说，如 $4$ 个符号组成的文本 `"CATS"` 用 $4$ 个 $n$ 位模式表示，任何一个模式定义一个单独的符号

### 编码

不同的位模式集合被设计用于表示文本符号。其中每一个集合我们称之为代码。 **表示符号的过程被称为 _编码_**。**位模式的长度取决于符号的数量**，但是它们的关系并不是线性的，而是对数的；即，如果需要编码 $N$个符号，长度将是 $\log_2 N$

> [!TIP] 编码 $n$ 个字符需要的位模式长度为 $\log_{2}{n}$


### ASCII 编码

美国国家标准协会(`ANSI`)开发了一个被称为 **美国信息交换标准码**(`ASCII`)的代码。该代码使用 $7$ 位表示每个符号。即该代码可以定义 $2^7=128$ 种不同的符号。用于表示 `ASCII` 码的完整位模式如下表

![[assets/images/Pasted image 20240621145612.png|900]]
![[assets/images/Pasted image 20240621145525.png|900]]

> [!NOTE] 如今 `ASCII` 是`Unicode` 的一部分

需要记忆的几个字符编码

|         字符         |    位模式     | 十进制  |  十六进制   |
| :----------------: | :--------: | :--: | :-----: |
| `NULL` 字符 (`'\0'`) | `000 0000` | `0`  | `0x00 ` |
| `SPACE` 字符 (`' '`) | `010 0000` | `32` | `0x20 ` |
|  `HT` 字符 (`'\t'`)  | `000 1001` | `9`  | `0x09 ` |
|  `CR` 字符 (`'\r'`)  | `000 1101` | `13` | `0x0d ` |
|  `LF` 字符 (`'\n'`)  | `000 1010` | `10` | `0x0a ` |
|  `VT` 字符 (`'\v'`)  | `000 1011` | `11` | `0x0b ` |
|  `FF` 字符 (`'\f'`)  | `000 1100` | `12` | `0x0c ` |
|      字符 `'0'`      | `011 0000` | `48` | `0x30 ` |
|      字符 `'1'`      | `011 0001` | `49` | `0x31 ` |
|      字符 `'A'`      | `100 0001` | `65` | `0x41 ` |
|      字符 `'a'`      | `110 0001` | `97` | `0x61`  |

### Unicode 编码

随着计算机在全世界的普及和互联网的发展，让计算机能处理特定区域的文本迫在眉睫。每个地区都设计了能够处理当地文本的字符集。例如，中国的 `GB/T 2312, GBK`，日本的 `Shift JIS` 等编码

由于不同地区使用的字符集编码方式不同，在不同国家间就会经常出现不兼容的情况。很多传统的编码方式都有共同的问题，即容许电脑处理双语环境（通常使用拉丁字母以及其本地语言），但却无法同时支持多语言环境（指可同时处理多种语言混合的情况）。

为此，硬件和软件制造商联合起来共同设计了一种名为 `Unicode` 的代码，称为 **统一码**。它 **为每一个字符而非字形定义唯一的代码（即一个整数）**

> [!TIP] **字符的视觉演绎留给其他软件处理**
> 
> **统一码以一种抽象的方式（即数字）来处理字符，并将字体大小、外观形状、字体形态、文体等工作留给其他软件来处理**

Unicode 编码系统可分为 **编码方式** 和 **实现方式** 两个层次

#### 编码方式

目前实际应用的统一码版本对应于 **UCS-2**，使用 $16$ 位的编码空间。也就是每个字符占用 $2$ 个字节。这样理论上一共最多可以表示 $2^{16}$（即 $65536$）个字符。基本满足各种语言的使用

最新（但未实际广泛使用）的统一码版本定义了 $16$ 个辅助平面，两者合起来至少需要占据 $21$ 位的编码空间，比 $3$ 字节略少。但事实上辅助平面字符仍然占用 $4$ 字节编码空间，与 **UCS-4** 保持一致

#### 实现方式 UTF-8

Unicode 编码方式确定了字符的二进制表示。但是，需要存储字符串时，如何存储呢？首先就是直接存储这些编号的位模式。如下实例

```
"hello, 世界!"
字符 编号(hex)  位模式
h    68        01101000
e    65        01100101
l    6c        01101100
l    6c        01101100
o    6f        01101111
,    2c        00101100
     20        00100000
世   4E16      01001110 00010110
界   754C      01110101 01001100
!    21        00100001

011010000110010101101100011011000110111100101100001000000100111000010110011101010100110000100001
```

> [!question] 直接存储字符的位模式有一个棘手的问题！**如何区分字符边界？**

首先想到的就是按照编码最长的位模式存储，不足的在左边使用 $0$ 补齐位模式。比如，按照 UCS-2 标准编码的字符，需要如下方式存储 `"hello, 世界!"` 
```
00000000 01101000
00000000 01100101
00000000 01101100
00000000 01101100
00000000 01101111
00000000 00101100
00000000 00100000
01001110 00010110
01110101 01001100
00000000 00100001
```

> [!question] 好多字节存储的都是 $0$，这些 $0$ 都是无效为，比较浪费内存

---

一个字符的 Unicode 代码是确定。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及 **出于 _节省空间_ 的目的**，对 Unicode 编码的实现方式有所不同。**Unicode 的实现方式称为 Unicode 转换格式（Unicode Transformation Format，简称为`UTF`）**。最常用的 `UTF-8(8-bit Unicode Transformation Format)` 编码

> [!tip] UTF-8 转换格式采用了如下转换模板
> ```
> U+0000 .... U+007F(0 ~ 127)      0xxxxxxx
> U+0080 .... U+07FF(128~2047)     110xxxxx 10xxxxxx
> U+0800 .... U+FFFF(2048~65535)   1110xxxx 10xxxxxx 10xxxxxx
> ```

UTF-8 使用 $1 \sim 6$ 个字节为每个字符编码（尽管如此，2003年11月 UTF-8 被 RFC 3629 重新规范，只能使用原来 Unicode 定义的区域，U+0000 到 U+10FFFF，也就是说 **最多四个字节**）。比如

```
"hello, 世界!"
字符 编号(hex)  位模式
h    68        01101000
e    65        01100101
l    6c        01101100
l    6c        01101100
o    6f        01101111
,    2c        00101100
     20        00100000
世   4E16      01001110 00010110
界   754C      01110101 01001100
!    21        00100001

01101000 01100101 01101100 01101100 01101111 00101100 00100000 11100100 10111000 10010110 11100111 10010101 10001100 00100001
```

> [!NOTE] UTF-8 编码 UCS-4 的编码范围为 `U+0000` 到 `U+10FFFF`

下图展示了 Unicode 与 UTF-8 的转换过程

![[assets/images/Pasted image 20240621150535.png|900]]
