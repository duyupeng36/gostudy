# 网络

对于同⼀台设备上的进程间通信，有很多种⽅式，⽐如有管道、消息队列、共享内存、信号等⽅式，⽽对于不同设备上的进程间通信，就需要⽹络通信，⽽设备是多样性的，所以要兼容多种多样的设备，就协商出了⼀套通⽤的 **⽹络协议**

> [!tip]
> 网络的出现是为了提供给两个运行在不同计算机上的进程进行同行的

## 互联网

**互联网**，会将不同的计算机网络连接起来并允许位于网络中的主机相互之间进行通信

> [!tip]
>互联网即 **网络的网络**，其中的一个网络称为 **子网**

下图就是一个简单的互联网


![[Drawing 2024-08-02 09.08.44.excalidraw|900]]

机器 `tekapo` 是一种 **路由器**，它一台 **将一个子网络连接到另一个子网络** 并在它们之间传输数据的计算机

为了使互联之间进行通信，设计出了多种互联网互联协议。其中， `TCP/IP` 是使用为最广泛的 **协议套件** 

## 联网协议和分层

一个**联网协议**是 **定义如何在一个网络上传输信息的一组规则**。**联网协议** 通常会 **被组织成一系列的层**

> [!tip]
> 每一层都构建于下层之上并提供特性以供上层使用

**TCP/IP 协议套件** 是一个 **分层联网协议**。如下图

![[Drawing 2024-08-02 09.16.00.excalidraw|900]]

**TCP/IP** 包括 **_因特网协议(IP)_** 和位于 **其上层的各个协议层**。（实现这些层的代码通常被称为协议栈。）名字 TCP/IP 是从 **_传输控制协议(TCP)_** 是使用最为广泛的传输层协议这样一个事实而得出来的

协议分层如此强大和灵活的其中一个原因是透明：**_每一个协议层都对上层隐藏下层的操作和复杂性_**

> [!example] 每个协议层对其上层隐藏实现细节
> 如一个使用 TCP 的应用程序只需要使用标准的 `socket API` 并清楚自己正在使用一项可靠的字节流传输服务，而无需理解 TCP 操作的细节。应用程序也无需知道 IP 和数据链路层的操作细节
> 
> 

下图展示了通过 TCP/IP 协议进行的分层通信

![[Drawing 2024-08-02 09.37.06.excalidraw|900]]

**封装** 是分层联网协议中的一个重要的原则，每个协议层都将上层数据包装为它能识别的数据。下图给出了 TCP/IP 协议层中的封装

![[Drawing 2024-08-02 09.50.47.excalidraw|900]]

> [!tip]
> 封装中的关键概念是 **低层会将从高层向低层传递的信息（如应用程序数据、TCP 段、IP 数据报）当成不透明的数据来处理**

换句话说，**_低层不会尝试对高层发送过来的信息进行解释_**，而只会将这些信息放到低层所使用的包中并在将这个包向下传递到低层之前 **添加自身这一层的头信息**

> [!tip]
>当数据从低层传递到高层时将会进行一个逆向的 **解包** 过程

## TCP/IP 分层协议

### 应用层

最上层的，也是我们能直接接触到的就是 **应⽤层**，我们电脑或⼿机使⽤的 _应⽤软件都是在应⽤层实现_。那么，当两个不同设备的应⽤需要通信的时候，应⽤就把应⽤数据传给下⼀层，也就是传输层

> [!tip] 
> **应⽤层只需要专注于为⽤户提供应⽤服务**，⽐如 HTTP、FTP、Telnet、DNS、SMTP等

_应⽤层是不⽤去关⼼数据是如何传输的_，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关⼼快递是如何被运输的

### 传输层

应⽤层的数据包会传给传输层，**传输层** 是为应⽤层提供⽹络⽀持的。在传输层会有两个传输协议，分别是 TCP 和 UDP

> [!tip] TCP 和 UDP
> 
>  **UDP** 的全称叫 _用户数据报协议_（User Datagram Protocol）相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对⽅，但它实时性相对更好，传输效率也⾼
>  
> **TCP**  的全称叫 _传输控制协议_（Transmission Control Protocol），⼤部分应⽤使⽤的正是 TCP 传输层协议，⽐如 HTTP 应⽤层协议。TCP 相⽐  UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅
> 
> 当然，UDP 也可以实现可靠传输，把 TCP 的特性在应⽤层上实现就可以，不过要实现⼀个商⽤的可靠 UDP 传输协议，也不是⼀件简单的事情

应⽤需要传输的数据可能会⾮常⼤，如果直接传输就不好控制，因此当传输层的数据包⼤⼩超过 **MSS（TCP 最⼤报⽂段⻓度）** ，就要将数据包 **分块**，这样即使中途有⼀个分块丢失或损坏了，只需要重新发送这⼀个分块，⽽不⽤重新发送整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 **_TCP 段（TCP Segment）_**

![[Drawing 2024-08-02 10.19.02.excalidraw|900]]

#### 端口

当设备作为接收⽅时，**传输层则要负责把数据包传给进程**，但是⼀台设备上可能会有很多进程在接收或者传输数据，因此需要 _⽤⼀个 **编号** 将应⽤区分开来_，这个编号就是 **_端⼝_**

> [!tip] 端口是一个 $16$ 位的数字
> 

有些 **_众所周知的端口号_** 已经被永久地分配给特定的应用程序。下表列出了几个常见的

|   端口号   | 应用程序              |
| :-----: | :---------------- |
|  $21$   | `FTP` 文件传输服务      |
|  $22$   | `ssh` 安全的 `shell` |
|  $23$   | `TELNET` 终端仿真服务   |
|  $25$   | `SMTP` 简单邮件传输服务   |
|  $53$   | `DNS` 域名解析服务      |
| $67,68$ | `DHCP` 服务器和客户端    |
|  $80$   | `HTTP` Web服务器     |
|  $443$  | `HTTPS` Web服务器    |


> [!tip]
> 由于传输层的报⽂中会携带端⼝号，因此接收⽅可以识别出该报⽂是发送给哪个进程

### 网络层

传输层可能⼤家刚接触的时候，会认为它负责将数据从⼀个设备传输到另⼀个设备，事实上它并不负责

> [!tip] 网络环境非常复杂：从一个设备传输到另一个设备需要进行网络节点的选择(路由)
> 实际场景中的⽹络环节是错综复杂的，中间有各种各样的线路和分叉路⼝。如果⼀个设备的数据要传输给另⼀个设备，就需要在各种各样的路径和节点进⾏选择。传输层的设计理念是简单、⾼效、专注，如果传输层还负责这⼀块功能就有点违背设计原则了

也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应⽤即可，让其作为应⽤间数据传输的媒介，帮助实现应⽤到应⽤的通信，⽽实际的传输功能就交给下⼀层，也就是 **_⽹络层（Internet Layer）_**

⽹络层最常使⽤的是 **IP 协议（Internet Protocol）**，IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装成 IP 报⽂，如果 IP 报⽂⼤⼩超过 **MTU（以太⽹中⼀般为 1500 字节）** 就会 _再次进⾏分⽚_，得到⼀个即将发送到⽹络的 IP 报⽂。

![[Drawing 2024-08-02 10.56.52.excalidraw|900]]

⽹络层负责将数据从⼀个设备传输到另⼀个设备，世界上那么多设备，⼜该如何找到对⽅呢？因此，_⽹络层需要有 **区分设备的编号**_。

#### IP 地址

 **IP 地址** 给网络中的设备进⾏编号，对于 IPv4 协议，**一个 IPv4 地址包含 $32$ 位**。当以人类可读的形式来表示时，这些地址通常的书写通常采用 **_点分十进制标记法_**，即将地址的 **_每个字节都写成一个十进制数字_**，中间 **以点号隔开**，如 `204.152.189.116`
 
 只有⼀个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道⼀个⼀个去匹配？这显然不科学。

一个 IP 地址包含两个部分：一个是 **_网络 ID_**，它指定了 **主机所属的网络**；另一个是 **_主机 ID_**，它标识出了 **位于该网络中的主机**

怎么划分网络 ID 和主机 ID 的呢？这需要配合 **网络掩码**。下图展示 IP 地址和网络码的组成部分

![[Drawing 2024-08-02 11.16.27.excalidraw|900]]


当一个组织为其主机申请一组 IPv4 地址时，它会收到一个 $32$ 位的 **IP地址** 以及一个对应的 $32$ 位的 **网络掩码**。在二进制形式中，这个 **掩码最左边的位由 $1$ 构成**，掩码中 **剩余的位用 $0$ 填充**

> [!tip] 
>  $1$ 表示地址中哪些部分包含了所 **分配到的网络 ID**
>  
>  $0$ 则表示地址中哪些部分可供组织用来为 **网络中的主机分配唯一的 ID**

**掩码中网络 ID 部分的大小会在分配地址时确定**。由于 **网络 ID 部分总是占据着掩码最左边的部分**，因此可以通过下面的标记法来指定分配的地址范围

```
204.152.189.0/24
```

后⾯的 `/24` 表示就是 `255.255.255.0`  ⼦⽹掩码，`255.255.255.0` ⼆进制是 `「11111111-11111111-11111111-00000000」`

拥有这个地址的组织可以将 $254$ 个唯一的因特网地址分配给其计算机——`204.152.189.1` 到`204.152.189.254`

> [!tip] 有两个地址是无法分配给计算机的 
> 
> ![[Drawing 2024-08-02 11.25.16.excalidraw|900]]
> 
> **主机 ID 的位都是 0**，它用来 **标识网络本身**
> 
> **主机 ID 的位都是 1**，它是 **子网广播地址**

#### 寻址 和 路由

知道网络掩码，该怎么计算出一个 IP 地址的⽹络 ID 和主机 ID 呢？将 _IP地址_ 和 _网络掩码_ 进⾏ **按位与运算**，就可以得到⽹络ID，如下图

![[Pasted image 20240802113825.png|900]]

将 网络掩码 **_取反_** 后与 IP地址 进⾏进⾏按位与运算，就可以得到主机号。

>[!tip] IP 寻址过程
>先匹配到相同的 ⽹络ID（表示要找到同⼀个⼦⽹），才会去找对应的 主机ID

除了寻址能⼒， IP 协议还有另⼀个重要的能⼒就是 **_路由_**。实际场景中，**两台设备**并不是⽤⼀条⽹线连接起来的，⽽是 **通过很多⽹关、路由器、交换机等 _众多⽹络设备连接_ 起来的，那么就会 _形成很多条⽹络的路径_**，因此当数据包到达⼀个⽹络节点，就需要通过 **_路由算法决定下⼀步⾛哪条路径_**

路由器寻址⼯作中，就是要找到⽬标地址的⼦⽹，找到后进⽽把数据包转发给对应的⽹络内

下图展示了路由过程

![[Pasted image 20240802114501.png|900]]

所以，IP 协议的 **_寻址_ 作⽤是告诉我们 _去往下⼀个⽬的地该朝哪个⽅向⾛_**，**_路由_ 则是根据「下⼀个⽬的地」_选择路径_**。寻址更像在导航，路由更像在操作⽅向盘

### 数据链路层

⽣成了 IP 头部之后，接下来要交给 **数据链路层** 在 IP 头部的前⾯加上 **MAC 头部**，并封装成 **数据帧（Data frame）** 发送到⽹络上

IP 头部中的接收⽅ IP 地址表示⽹络包的⽬的地，通过这个地址我们就可以判断要将包发到哪⾥，但在以太⽹的世界中，这个思路是⾏不通的

> [!tip] 以太网
> 
> 以太⽹就是⼀种在 **「局域⽹」** 内，把附近的设备连接起来，使它们之间可以进⾏通讯的技术


以太⽹在判断⽹络包⽬的地时和 IP 的⽅式不同，因此必须采⽤相匹配的⽅式才能在以太⽹中将包发往⽬的地，⽽ **MAC 头部** 就是⼲这个⽤的，所以，**在以太⽹进⾏通讯要⽤到 _MAC 地址_**。

> [!tip]
> MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息，我们可以通过 ARP 协议获取对⽅的 MAC 地址

> [!tip]
> 数据链路层主要为⽹络层提供 **「链路级别」传输的服务**，负责在以太⽹、WiFi 这样的 **底层⽹络上发送原始数据包**，⼯作在⽹卡这个层次，使⽤ **MAC 地址来标识⽹络上的设备**。

### 总结

综上所述，TCP/IP ⽹络通常是由上到下分成 $4$ 层，分别是 **应⽤层，传输层，⽹络层和⽹络接⼝层**

每⼀层都将数据封装成自己的格式，每个协议层不会处理其他层的数据

数据链路层的传输单位是 **帧（frame）**，网络层的传输单位是 **包（packet）**，传输层的传输单位是 **段（segment）**，HTTP 的传输单位则是消息或报⽂（message）。但这些名词并没有什么本质的区分，可以统称为数据包。下图总结了每层的封包情况

![[Pasted image 20240802123535.png|900]]

## 相关协议介绍

### 应用层协议

**应用层协议** 定义了运行在 **不同端系统**上的应用程序 **进程** 是如何相互 **传递数据包**

#### HTTP 协议

Web 的应用层协议是 **超文本传输协议(Hyper Text Transfer Protocol, _HTTP_)**，它是 Web 的核心。 HTTP 由两个程序实现：**客户程序** 和 **服务程序**

> [!tip] HTTP 由两个程序实现：**客户端序** 和 **服务程序**
>
>客户程序和服务器程序 **运行在不同的端系统** 中，通过交换 **HTTP 报文** 进行会话
> 
> HTTP 定义了这些 **_报文的结构_** 以及客户和服务器进行 **_报文交换的方式_**

**HTTP 使用 TCP 作为它的支撑运输协议**。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过 **套接字接口** 访问 TCP

> [!tip]
> 
> 客户向它的套接字接口发送 **HTTP请求报文** 并从它的套接字接口接收 **HTTP响应报文**
> 
> 服务器从它的套接字接口接收 **HTTP请求报文** 和向它的套接字接口发送 **HTTP响应报文**

**TCP 为 HTTP 提供可靠数据传输服务**。一个客户进程发出的每个 HTTP 请求报文最终能完整地到达服务器；类似地，服务器进程发出的每个 HTTP 响应报文最终能完整地到达客户

> [!tip] 分层体系结构的优点
> 
> 这里我们看到了 **分层体系结构最大的优点**，即 HTTP 协议不用担心数据丢失，也不关注 TCP 从网络的数据丢失和乱序故障中恢复的细节

> [!tip] HTTP 是无状态的
> 
> **HTTP服务器并不保存关于客户的任何信息**，所以我们说HTTP是一个 **无状态协议**

> [!tip] 持续连接和非持续连接
> 
> 如果应用程序的 **每个请求/响应对是经一个 _单独_ 的 TCP 连接发送**，则称应用程序使用了 **非持续连接**
> 
> 如果应用程序的 **所有的请求及其响应经 _相同_ 的TCP连接发送**，则称应用程序使用了 **持续连接**

##### 统一资源定位符(URL)

**_Web页面_ (也叫文档）是由 _对象_ 组成的**。**一个 _对象_ 只是一个 _文件_**，且可通过一个 **_URL 地址寻址_**

> [!tip]
> 
> Web页面含有一个 **HTML** 基本文件以及几个引用对象

HTML 基本文件通过对象的 **_URL地址_** 引用页面中的其他对象。每个 URL 地址由两部分组成：**存放对象的服务 _主机名_** 和 **对象的 _路径名_**。下图展示了组成 URL 的基本元素

![[Pasted image 20240802172049.png|900]]

> [!tip]
> URL 实际上是请求服务器⾥的⽂件资源
> 
> ![[Pasted image 20240802170523.png|900]]
> 
> ![[Pasted image 20240802170558.png|900]]

##### 浏览器和服务器

> [!tip] **Web 浏览器** 与 **Web 服务器**
> 
> **Web浏览器**(Web browser) 实现了 _HTTP的客户端_
> 
> **Web服务器**(Weh server)实现了 _HTTP的服务器端_，它用于 **存储 Web对象**，每个 **对象由 URL 寻址**

##### HTTP 请求报文

对 URL  进⾏解析之后，浏览器确定了 Web 服务器和⽂件名，当用户请求一个 Web 页面（如点击一个超链接）时，浏览器向服务器发出对该页面中所包含对象的 **HTTP 请求报文**

下图展示了 HTTP 请求报文的格式

![[Pasted image 20240802171230.png|900]]

HTTP 请求报文被划分了 $3$ 部分：**请求行** **首部行** 和 **消息体**。下面是 HTTP GET 请求的报文格式

```
GET /somedir/page.html HTTP/1.1   # 请求行
Host: www.somescholl.edu
Connection: close
User-Agent: Mozilla/5.0
Accept-language: fr

# 实体体
```


###### 请求行

> [!tip] 请求行：由 $3$ 部分组成
> 
> 请求行由 **请求方法**、**URL** 和 **HTTP 版本** 三部分组成。每部分由 **空格** 分隔。最后再附加上 `\r\n` 作为结束标识

HTTP 定义几种不同的方法，其中最常用的就是 `GET` 和 `POST` 这两个方法。下表列出了 HTTP/1.1 提供的方法及其作用

|    方法     | 描述                    | 备注                     |
| :-------: | :-------------------- | :--------------------- |
|   `GET`   | 请求获取一个对象              |                        |
|  `POST`   | 从客户端向服务器发送数据          | 一般用于发送表单中填写的数据等情况下     |
|  `HEAD`   | 只返回 HTTP 的消息头         | 类似于 `GET` ，用于获取文件的属性信息 |
| `OPTIONS` | 用于通知或查询通信选项           |                        |
|   `PUT`   | 替换 URI 指定的服务器上的文件     | 如果 URI 指定的文件不存在，则创建该文件 |
| `DELETE`  | 删除 URI 指定的服务器上的文件     |                        |
|  `TRACE`  | 将服务器收到的请求行和头部直接返回给客户端 | 用于在使用代理的环境中检查改写请求的情况   |
| `CONNECT` | 使用代理传输加密消息时使用的方法      |                        |

> [!tip]
> URL 作为访问资源的路径，在 HTTP 请求报文中 **只有资源路径才会被存放在请求行中**

HTTP 版本由 Web 浏览器确定。HTTP 版本以 `"HTTP/1.1"` 这种形式表示

###### 首部行

这一部分也称为 **消息头**，**每行包含一个首部字段**，用于 **表示请求的附加信息**。消息头的行数根据具体情况可变，**一直延伸到空行为止**

> [!tip] 首部行：**紧挨着请求行** 的连续几行都是 `首部字段: 值` 
> 
> 首部字段可以是标准 HTTP 协议提供的字段，也可以自定义

###### 消息体

> [!important] 
> 在 HTTP 请求报文中消息体与首部行之间存在一个 `\r\n` 的换行符


> [!attention] HTTP 请求报文的消息体可以为空
> 
> 当 HTTP 客户端发起 GET 方法的请求时，消息体通常为空
> 
> 当 HTTP 客户端发起 POST 方法的请求时，消息体一般会携带数据

##### HTTP 响应报文

服务器接收到客户端的请求后，就会使用用包含客户端请求的数据对象构建 **HTTP响应报文** 进行响应

下图展示了 HTTP 响应报文的格式

![[Pasted image 20240802173930.png|900]]

HTTP 响应报文同样分为了三部分：**状态行**、**首部行** 和 **消息体**。下面是一个典型的 HTTP 响应报文

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.23 (CentOS)
Last-Modified: True, 18 AUg 2015 15:11:03 GMT
Contnet-Length: 6821
Contnet-Type: text/html

# 数据
```

###### 状态行

> [!tip] HTTP 响应报文的状态行包括 $3$ 部分内容
> 
> HTTP 响应报文的状态行包括：**HTTP 版本**、**状态码** 和 **状态短语** 三部分，每个部分由 **空格** 分隔
> 
> 状态码和短语指示了请求的结果

下表列出了一些常见的状态码和短语及其含义

|  状态码  | 短语                                | 含义                                                                                                         |
| :---: | :-------------------------------- | :--------------------------------------------------------------------------------------------------------- |
| `100` | `Continue`                        | 继续。**客户端应继续其请求**                                                                                           |
| `101` | `Switching Protocols`             | **切换协议**。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议                                                    |
|       |                                   |                                                                                                            |
| `200` | `OK`                              | **请求成功**，信息在返回的响应报文中。一般用于 `GET` 与 `POST` 请求                                                                |
| `201` | `Created`                         | **已创建**。成功请求并创建了新的资源                                                                                       |
| `202` | `Accepted`                        | **已接受**。已经接受请求，但未处理完成                                                                                      |
| `203` | `Non-Authoritative Information`   | **非授权信息**。请求成功。但返回的 `meta` 信息不在原始的服务器，而是一个副本                                                               |
| `204` | `No Content`                      | **无内容**。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档                                                           |
| `205` | `Partial Content`                 | **部分内容**。服务器成功处理了部分GET请求                                                                                   |
|       |                                   |                                                                                                            |
| `301` | `Moved Permanently`               | 请求的 **对象已经被永久转移** 了，新的 `URL` 定义在响应报文的首部行的 `Location` 字段中。客户软件将自动获取新的 `URL`                                 |
| `302` | `Found`                           | **临时移动**。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 `URI`                                                              |
| `303` | `See Other`                       | 查看其它地址。与301类似。使用GET和POST请求查看                                                                               |
| `304` | `Not Modified`                    | 未修改。**所请求的资源未修改**，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源                       |
| `305` | `Use Proxy`                       | 使用代理。所请求的资源必须通过代理访问                                                                                        |
| `306` | `Unused`                          | 已经被废弃的HTTP状态码                                                                                              |
| `307` | `Temporary Redirect`              | **临时重定向**。与 302 类似。使用 GET 请求重定向                                                                            |
|       |                                   |                                                                                                            |
| `400` | `Bad Request`                     | 一个通用差错代码，指示该 **请求不能被服务器理解**                                                                                |
| `401` | `Unauthorized`                    | 请求要求用户的身份认证                                                                                                |
| `402` | `Payment Required`                | 保留，将来使用                                                                                                    |
| `403` | `Forbidden`                       | 服务器理解请求客户端的请求，但是 **拒绝执行此请求**                                                                               |
| `404` | `Not Found`                       | 被请求的文档不在服务器上                                                                                               |
| `405` | `Method Not Allowed`              | 客户端请求中的方法被禁止                                                                                               |
| `406` | `Not Acceptable`                  | 服务器无法根据客户端请求的内容特性完成请求                                                                                      |
| `407` | `Proxy Authentication Required`   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权                                                                          |
| `408` | `Request Time-out`                | 服务器等待客户端发送的请求时间过长，超时                                                                                       |
| `409` | `Conflict`                        | 服务器完成客户端的 `PUT` 请求时可能返回此代码，服务器处理请求时发生了 **冲突**                                                              |
| `410` | `Gone`                            | 客户端请求的资源已经不存在。`410` 不同于 `404`，如果资源以前有现在被永久删除了可使用 `410` 代码，网站设计人员可通过 `301` 代码指定资源的新位置                       |
| `411` | `Length Required`                 | 服务器无法处理客户端发送的不带` Content-Length` 的请求信息                                                                     |
| `412` | `Precondition Failed`             | 客户端请求信息的先决条件错误                                                                                             |
| `413` | `Request Entity Too Large`        | 由于 **请求的实体过大**，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 `Retry-After` 的响应信息              |
| `414` | `Request-URI Too Large`           | **请求的URI过长**（URI通常为网址），服务器无法处理                                                                             |
| `415` | `Unsupported Media Type`          | 服务器无法处理请求附带的媒体格式                                                                                           |
| `416` | `Requested range not satisfiable` | 客户端请求的范围无效                                                                                                 |
| `417` | `I'm a teapot`                    | 服务器无法满足 `Expect` 的请求头信息                                                                                    |
| `418` | `I'm a teapot`                    | 状态码 418 实际上是一个愚人节玩笑。它在 RFC 2324 中定义，该 RFC 是一个关于超文本咖啡壶控制协议（HTCPCP）的笑话文件。在这个笑话中，418 状态码是作为一个玩笑加入到 HTTP 协议中的。 |
|       |                                   |                                                                                                            |
| `500` | `Internal Server Error`           | 服务器内部错误，无法完成请求                                                                                             |
| `501` | `Not Implemented`                 | 服务器不支持请求的功能，无法完成请求                                                                                         |
| `502` | `Bad Gateway`                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应                                                                    |
| `503` | `Service Unavailable`             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中                                                    |
| `504` | `Gateway Time-out`                | 充当网关或代理的服务器，未及时从远端服务器获取请求                                                                                  |
| `505` | `HTTP Version Not Supported`      | 服务器不支持请求报文使用的 `HTTP` 协议版本                                                                                  |

[MDN-HTTP 响应状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status) 完整的列出来所有被 HTTP 标准定义的状态码

###### 首部行

参考 HTTP 请求报文中的首部行，他们的格式是一样的

###### 消息体

HTTP 的响应数据全部携带在消息体中，消息体与首部行之间存在一个 `\r\n` 的换行符

##### Cookie

**_HTTP 服务器是无状态的_**。这简化了服务器的设计，并且允许工程师们去开发可以同时处理数以千计的 TCP 连接的高性能 Web 服务器

然而一个 **_Web 站点通常希望能够识别用户_**，可能是因为 **服务器希望限制用户的访问**，或者因为它希望把内容与用户身份联系起来。为此，**HTTP 使用了 `cookie`**，它允许站点对用户进行跟踪

> [!tip] `cookie` 技术的 $4$ 个组件
> 在 **HTTP 响应报文** 中的一个 **cookie 首部行**
> 
> 在 **HTTP 请求报文** 中的一个 **cookie 首部行**
>  
> 在 **用户端系统中保留有一个 cookie 文件**，并由用户的 **浏览器进行管理**
> 
> 位于 **Web 站点的一个后端数据库**

下图给出了一个典型的 `cookie` 的工作流程

![[Pasted image 20240802175927.png|900]]

 首次请求站点时，当 **请求报文** 到达站点服务器时，该 Web 站点将产生一个 **唯一识别码**，并以此作为索引在它的后端数据库中产生一个表项

然后，站点服务器用一个包含 `Set-cookie` 首部行的 HTTP 响应报文对浏览器进行响应，其中 **`Set-cookie` 首部行包含由识别码**

浏览器收到该 HTTP响应报文 时，它会看到该 `Set-cookie:` 首部。该浏览器在它管理的特定 `cookie` 文件中添加一行，该行包含服务器的主机名和在 `Set-cookie : `首部中的识别码

之后的每请求一个 Web 页面，其浏览器就会查询该 `cookie` 文件并抽取她对这个网站的识别码，并放到 **HTTP 请求报文中包括识别码的 `cookie` 首部行**

**`cookie` 可以用于标识一个用户**。用户首次访问一个站点时，可能需要提供一个用户标识（可能是名字）。在后继会话中，浏览器向服务器传递一个 `cookie` 首部，从而向该服务器标识了用户。因此 **`cookie` 可以在无状态 HTTP 之上建立一个用户会话层**

##### Web 缓存

**Web 缓存器** 也叫 **代理服务器** , 它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体

> [!tip] Web 缓存器
> 
> 它 **有自己的磁盘存储空间**
> 
> 在存储空间中保存 **最近请求过的对象的副本**

假设浏览器正在请求对象 `http://www.someschool.edu/campus.gif`，如果配置了 Web 缓存器将会发生如下情况
浏览器创建一个到 Web 缓存器的 TCP 连接，并向 Web 缓存器中的对象发送一个HTTP 请求
- Web 缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web 缓存器就向客户浏览器用 HTTP 响应报文返回该对象
- 如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器（即 `www. someschool.edu`)的TCP连接。Web 缓存器则在这个缓存器到服务器的 TCP 连接上发送一个对该对象的 HTTP 请求。在收到该请求后，初始服务器向该 Web 缓存器发送具有该对象的 HTTP 响应
- 当 Web 缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用 HTTP 响应报文发送该副本

> [!tip] Web 缓存器即使服务器也是客户端
> 当它接收浏览器的请求并发回响应时，它是一个服务器
> 
> 当它向初始服务器发出请求并接收响应时，它是一个客户端

下图显示没有 Web 缓冲器的网络

![[Pasted image 20240802181104.png|900]]

机构网络是一个高速的局域网，它的一台路由器与因特网上的一台路由器通过一条 `15Mbps` 的链路连接。这些初始服务器与因特网相连但位于全世界各地。假设对象的平均长度为 `1Mb`, 从机构内的浏览器对这些初始服务器的平均访问速率为每秒 $15$ 个请求
- 假设 HTTP 请求报文小到可以忽略，因而不会在网络中以及接入链路（从机构内部路由器到因特网路由器）上产生什么通信量
- 还假设在从因特网接入链路一侧的路由器转发 HTTP 请求报文（在一个 IP 数据报中）开始，到它收到其响应报文（通常在多个IP数据报中）为止的时间平均为 $2$ 秒

总的响应时间，即从浏览器请求一个对象到接收到该对象为止的时间，是 **局域网时延**、**接入时延**（即两台路由器之间的时延）和 **因特网时延**之和。
- 局域网上的流最强度：`(15 个请求/s) * (1Mb/请求) / (100Mbps) = 0.15
- 接入链路上的流量强度: `(15 个请求/s) * (1Mb/请求) / (15Mbps) = 1

局域网上强度为 `0.15` 的通信量通常最多导致数十毫秒的时延，因此我们可以忽略局域网时延

流量强度接近 `1`，链路上的时延会变得非常大并且无限增长。满足请求的平均响应时间将在分钟的最级上。显然，必须想办法来改进时间响应特性

下图描绘了在机构网络中增加一个 Web 缓冲器

![[Pasted image 20240802181230.png|900]]

影响缓存性能是缓存的 **命中率**（即由一个缓存器所满足的请求的比率），通常在 $0.2 \sim 0.7$ 之间。假设该机构的缓存命中率为 $0.4$
- 这样 $40\%$ 的请求将几乎立即会由缓存器得到响应，时延约在 `10ms` 以内
- 然而，剩下的 $60\%$ 的请求仍然要由初始服务器来满足。但是只有 $60\%$ 的被请求对象通过接入链路，在接入链路上的流量强度从 $1.0$ 减小到 $0.6$

在 `15Mbps` 链路上，当流量强度小于 $0.8$ 时对应的时延较小，约为几十毫秒。这个时延与 $2$ 秒因特网时延相比是微不足道的。考虑这些之后，平均时延因此为: `0.4 * (0.010 秒) + 0.6 * (2.01 秒)`

通过使用 **_内容分发网络_**(Content Distribution Network, CDN) , Web缓存器正在因特网中发挥着越来越重要的作用。CDN公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化

##### HTTP 主要的首部字段

HTTP 首部字段提供丰富的信息，并且可以指导客户端的行为。下面就总结一下在HTTP请求和响应中常用的首部字段

首部字段根据实际用途被分为以下 $4$ 种类型：

|     类型     | 描述                    |
| :--------: | :-------------------- |
| **通用首部字段** | 请求报文和响应报文两方都会使用的首部    |
| **请求首部字段** | 从客户端向服务器端发送请求报文时使用的首部 |
| **响应首部字段** | 从服务器端向客户端返回响应报文时使用的首部 |
| **实体首部字段** | 针对请求报文和响应报文的实体部分使用的首部 |

###### 通用首部字段

|        首部字段名        | 说明            |
| :-----------------: | :------------ |
|   `Cache-Control`   | 控制缓存的行为       |
|    `Connection`     | 逐挑首部、连接的管理    |
|       `Date`        | 创建报文的日期时间     |
|      `Pragma`       | 报文指令          |
|      `Trailer`      | 报文末端的首部一览     |
| `Transfer-Encoding` | 指定报文主体的传输编码方式 |
|      `Upgrade`      | 升级为其他协议       |
|        `Via`        | 代理服务器的相关信息    |
|      `Warning`      | 错误通知          |


`Cache-Control` 控制缓存的行为。可用的指令可以按请求和响应

|         指令         | 参数  | 说明             |
| :----------------: | :-: | :------------- |
|     `no-cache`     |  无  | 强制向服务器再次验证     |
|     `no-store`     |  无  | 不缓存请求或响应的任何内容  |
|  `max-age = [秒]`   | 必需  | 响应的最大Age值      |
| `max-stale( =[秒])` | 可省略 | 接收已过期的响应       |
| `min-fresh = [秒]`  | 必需  | 期望在指定时间内的响应仍有效 |
|   `no-transform`   |  无  | 代理不可更改媒体类型     |
|  `only-if-cached`  |  无  | 从缓存获取资源        |
| `cache-extension`  |  -  | 新指令标记（token）   |

|         指令         | 参数  | 说明                    |
| :----------------: | :-: | :-------------------- |
|      `public`      |  无  | 可向任意方提供响应的缓存          |
|     `private`      | 可省略 | 仅向特定用户返回响应            |
|     `no-cache`     | 可省略 | 缓存前必须先确认其有效性          |
|     `no-store`     |  无  | 不缓存请求或响应的任何内容         |
|   `no-transform`   |  无  | 代理不可更改媒体类型            |
| `must-revalidate`  |  无  | 可缓存但必须再向源服务器进行确认      |
| `proxy-revalidate` |  无  | 中间缓存服务器对缓存的响应有效性再进行确认 |
|  `max-age = [秒]`   | 必需  | 响应的最大Age值             |
|  `s-maxage = [秒]`  | 必需  | 公共缓存服务器响应的最大Age值      |
| `cache-extension`  |  -  | 新指令标记（token）          |


`Connection` 首部字段具备以下两个作用：**控制不再转发的首部字段(`Upgrade`)** 和 **管理持久连接(`Keep-Alive` 和 `Close`)**

###### 请求首部字段

补充了请求的附加内容、客户端信息、响应内容相关优先级等信息

|         首部字段名         | 说明                                |
| :-------------------: | :-------------------------------- |
|       `Accept`        | 用户代理可处理的媒体类型                      |
|   `Accept-Charset`    | 优先的字符集                            |
|   `Accept-Encoding`   | 优先的内容编码                           |
|   `Accept-Language`   | 优先的语言（自然语言）                       |
|    `Authorization`    | Web认证信息                           |
|       `Expect`        | 期待服务器的特定行为                        |
|        `From`         | 用户的电子邮箱地址                         |
|        `Host`         | 请求资源所在服务器                         |
|      `If-Match`       | 比较实体标记（ETag）                      |
|  `If-Modified-Since`  | 比较资源的更新时间                         |
|    `If-None-Match`    | 比较实体标记（与 If-Macth 相反）             |
|      `If-Range`       | 资源未更新时发送实体 Byte 的范围请求             |
| `If-Unmodified-Since` | 比较资源的更新时间(与 If-Modified-Since 相反) |
|    `Max-Forwards`     | 最大传输逐跳数                           |
| `Proxy-Authorization` | 代理服务器要求客户端的认证信息                   |
|        `Range`        | 实体的字节范围请求                         |
|       `Referer`       | 对请求中 URI 的原始获取方                   |
|         `TE`          | 传输编码的优先级                          |
|     `User-Agent`      | HTTP 客户端程序的信息                     |


###### 响应首部字段

补充了响应的附加内容，也会要求客户端附加额外的内容信息

|        首部字段名         | 说明             |
| :------------------: | :------------- |
|   `Accept-Ranges`    | 是否接受字节范围请求     |
|        `Age`         | 推算资源创建经过时间     |
|        `ETag`        | 资源的匹配信息        |
|      `Location`      | 令客户端重定向至指定 URI |
| `Proxy-Authenticate` | 代理服务器对客户端的认证信息 |
|    `Retry-After`     | 对再次发起请求的时机要求   |
|       `Server`       | HTTP 服务器的安装信息  |
|        `Vary`        | 代理服务器缓存的管理信息   |
|  `WWW-Authenticate`  | 服务器对客户端的认证信息   |

###### 实体首部字段

补充了资源内容更新时间等与实体有关的的信息

|       首部字段名        |       说明       |
| :----------------: | :------------: |
|      `Allow`       | 资源可支持的 HTTP 方法 |
| `Content-Encoding` |  实体主体适用的编码方式   |
| `Content-Language` |   实体主体的自然语言    |
|  `Content-Length`  | 实体主体的大小（单位：字节） |
| `Content-Location` |  替代对应资源的 URI   |
|   `Content-MD5`    |   实体主体的报文摘要    |
|  `Content-Range`   |   实体主体的位置范围    |
|   `Content-Type`   |   实体主体的媒体类型    |
|     `Expires`      |  实体主体过期的日期时间   |
|  `Last-Modified`   |  资源的最后修改日期时间   |

###### 为 Cookie 服务的首部字段

|    首部字段名     |          说明          |  首部类型  |
| :----------: | :------------------: | :----: |
| `Set-Cookie` | 开始状态管理所使用的 Cookie 信息 | 响应首部字段 |
|   `Cookie`   |  服务器接收到的 Cookie 信息   | 请求首部字段 |

下面的表格列举了 Set-Cookie 的字段值。

|       属性       | 说明                                           |
| :------------: | :------------------------------------------- |
|  `NAME=VALUE`  | 赋予 Cookie 的名称和其值（必需项）                        |
| `expires=DATE` | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）              |
|  `path=PATH`   | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）   |
|  `domain=域名`   | 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名） |
|    `Secure`    | 仅在 HTTPS 安全通信时才会发送 Cookie                    |
|   `HttpOnly`   | 加以限制，使 Cookie 不能被 JavaScript 脚本访问            |

#### 真实地址查询：DNS

通过浏览器解析 `URL` 并⽣成 HTTP 请求报文，需要委托操作系统将 HTTP 请求报文 通过 TCP/IP 发送给 Web   服务器

但在发送之前，还有⼀项⼯作需要完成，那就是 **查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

> [!tip] 查询 IP 地址好比查询通讯录一样
> 
> ⽐如我们打电话的时候，必须要知道对⽅的电话号码，但由于电话号码难以记忆，所以通常我们会将对⽅电话号 + 姓名保存在通讯录⾥

所以，有⼀种服务器就专⻔保存了 Web  服务器域名与 IP  的对应关系，它就是  **DNS  服务器**。

> [!tip] DNS 服务器的 IP 实在配置网络时就知晓的
> 本地 DNS 服务器通常由路由器充当

DNS 中的域名都是⽤句点来分隔的，⽐如 `www.server.com `，这⾥的句点代表了不同层次之间的界限。在域名中，**越靠右的位置表示其层级越⾼**

> [!tip]
> 实际上域名最后还有⼀个点，⽐如 `www.server.com.` ，这个最后的⼀个点代表根域名


也就是， `.`  根域是在最顶层，它的下⼀层就是 `.com`  顶级域，再下⾯是 `server.com`。所以域名的层级关系类似⼀个树状结构。DNS 服务器也是这样的树状结构

+ 根 DNS 服务器（.）
+ 顶级域 DNS 服务器（.com）
+ 权威 DNS 服务器（server.com）

> [!tip]
>根域的 DNS 服务器信息保存在互联⽹中所有的 DNS 服务器中
>
>这样⼀来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了
>
>因此，客户端只要能够找到任意⼀台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再⼀路顺藤摸⽠找到位于下层的某台⽬标 DNS 服务器

域名解析的⼯作流程

![[Pasted image 20240802190131.png|900]]

### 传输层协议

#### UDP 协议

UDP 仅仅在 IP 之上添加了两个特性：**_端口号_** 和 **进行检测传输数据错误的 _数据校验和_**

与 IP 一样，**_UDP 也是无连接的_**。由于它并 **_没有在 IP 之上增加可靠性_**，因此 **_UDP 是不可靠的_**

> [!tip] 基于 UDP 的应用程序也可以实现可靠性传输，但是必须在应用程序中实现
> 
> 如果一个 **基于 UDP 的应用程序需要确保可靠性**，那么这项功能就 **必须要在应用程序中予以实现**。如果剔除不可靠这个特点的话，在有些时候可能倾向于使用 UDP 而不是 TCP

##### UDP 报文格式

应用层数据占用 UDP 报文段的数据字段。**UDP 首部只有 4 个字段**，**每个字段由两个字节组成**

![[Drawing 2024-08-02 19.06.30.excalidraw|900]]


**_尽可能地避免 IP 分段_**。TCP 提供了避免 IP 分段的机制，但 UDP 并没有提供相应的机制。使用 UDP 时如果传输的数据报的大小 **超过了本地数据链接的 MTU(以太网一般位 $1500$ 字节)，那么很容易就会导致 IP 分段**

**基于 UDP 的应用程序通常不会知道 源主机和目的主机之间的路径的 MTU**。一般来讲，基于 UDP 的应用程序会 **_采用保守的方法来避免 IP 分段_**

> [!tip]
> 确保传输的 IP 数据包的大小小于 IPv4 的组装缓冲区大小的最小值 $576$ 字节
> 
> 在这 576 字节中，有 **_8 个字节是用于存放 UDP 头_** 的，另外最少需要使用 **_20 个字节来存放 IP 头_**，**_剩下的 548 字节用于存放 UDP 数据报本身_**
> 
> 在实践中，很多基于 UDP 的应用程序会选择使用一个更小的值 $512$ 字节来存放数据报

#### TCP 协议

##### TCP 报文格式

![[Drawing 2024-08-02 19.18.10.excalidraw|900]]

⾸先，**源端⼝号(16 位)** 和 **⽬标端⼝号(16 位)** 是不可少的，如果没有这两个端⼝号，数据就不知道应该发给哪个应⽤

**序列号(SYN)(32 位)**： **TCP 发送端** 告知 **TCP 接收端** 该网络包是中的数据是所有数据中的第几个字节

**确认号(ACK)(32 位)**：**TCP 接受端** 告知 **TCP 发送端** 已经收到了所有数据中的第几个字节

**首部长度(4 位)**：表示 TCP 头部的长度

> [!tip]
> 指示了以 $32$ 比特的字为单位的 TCP首部长度。TCP首部的长度是可变的
> 
> 通常选项字段为空 ，所以 TCP 首部的典型长度是 $20$ 字节
> 

**保留位(4 位)**：该字段为保留，现在未使用

**控制位(8 位)**：该字段中的每个比特分别表示以下通信控制含义。一些老的实现只理解最后 $6$ 位
+ `CWR`：拥塞窗口减，发送方降低它的发送速率
+ `ECE`：`ECN` 回显，发送方接收到了一个更早的拥塞通告
+ `URG`：表示紧急指针字段有效
+ `ACK`：表示接收数据序号字段有效，连接建立后一般都是启用的状态
+ `PSH`：推送，接收方尽快的给应用程序传送这个数据，它没有被可靠的实现或用到
+ `RST`：重置连接，连接被取消，用于异常中断的情况
+ `SYN`：初始化一个连接的同步序号
+ `FIN`：该报文段的发送方已经结束向接收方发送数据

**窗口大小(16 位)**：TCP 要做 **流量控制**，窗口大小是字节数，接收方告知发送方窗口大小（即 **无需等待确认可一起发送的数据量**）。$16$ 位的字段，限制窗口大小到 $65535$ 字节

**校验和(16 位)**：用来检查是否出现错误

**紧急指针(16位)**：表示应紧急处理的数据位置

##### TCP 连接管理

下图展示了 TCP 连接的建立过程

![[Drawing 2024-08-02 21.18.28.excalidraw|900]]


> [!tip] 三次握手过程
> 
> 首先，客户端主动发送一个 **SYN 报文段(控制位 `SYN` 置位)** 给服务器，并指明自己想要 **连接的端口号(目标端口号)** 和 **客户端的初始序列号(`ISN(c)`)**
> 
> 然后，服务器在接收到客户端的 SYN 报文段后，就发送自己的 SYN 报文段作为响应。同时指明 **服务端的初始序列号(`ISN(s)`)**。与此同时，为了确认客户端的 SYN，服务器将客户端的 `ISN(c) + 1` 作为 ACK 号
> 
> 最后，客户端为了确认服务器的 SYN，客户端将服务器的 `ISN(s) + 1` 作为 ACK 号，同时将自己的 `ISN(c) + 1` 后发送给服务器
> 
> 没发送一个 SYN，序列号就会自动加 $1$，即使出现丢失情况，该 SYN 端就会重传

通过上述 $3$ 个报文段就能完成一个 TCP 连接的建立。通常被称为 **_三次握手_**。它不仅让通信双方了解一个连接正在建立，还利用数据包的选项来承载特殊信息，交换 **初始序列号(`ISN`)

> [!tip] 断开连接
> 
> 数据传输完成之后，任何一方都可以发起一个关闭操作，甚至是双方同时关闭连接的操作。传统情况下，**_负责发起关闭连接的通常是客户端_**
> 
> TCP协议规定通过发送一个 **FIN 报文段** 来发起关闭操作。**只有当连接双方都完成关闭操作后，才构成完整的关闭**
> 
> 首先，连接的 **主动关闭者** 发送一个 **FIN 报文段** 指明接收者希望看到自己的 **_当前序列号_ (接收者希望看到的) K**。 FIN 段还包含了一个 `ACK` 段用于确认对方最近一次发来的数据 L
> 
> 然后，连接的 **被动关闭者** 将 `K + 1` 作为响应的 `ACK` 值，表明它已成功接收到主动关闭者发送的 `FIN`
> 
> 此时，**上层应用程序会被告知连接的另一端已经提出关闭的请求**。此时，导致应用程序发起自己的关闭操作；接着，被动关闭者的身份将转变为主动关闭者，发送自己的 `FIN` 段，该段的序号为 `L`
> 
> 最后，为了完成连接的关闭，最后发送的报文段还包含一个 `ACK` 用于确认上一个 `FIN`。如果 `FIN` 出现丢失的情况，发送方还将重新传输直到接收到一个 `ACK` 确认为止

##### TCP 分割数据

应用层数据⽐较⻓，超过了 `MSS`  的⻓度，这时 TCP 就需要把 应用层数据拆解成⼀块块的数据发送，⽽不是⼀次性发送所有数据

![[Pasted image 20240802224434.png|900]]

> [!tip] 
> `MTU` ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500  字节
> 
> `MSS` ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度


数据会被以 `MSS`  的⻓度为单位进⾏拆分，拆分出来的每⼀块数据都会被放进单独的⽹络包中。也就是在 **每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据**

![[Drawing 2024-08-02 22.35.36.excalidraw|900]]

##### TCP 报⽂⽣成

假设使用浏览器向某个 Web 服务发送请求。TCP 协议⾥⾯会有两个端⼝，⼀个是 **浏览器监听的端⼝（通常是随机⽣成的）**，⼀个是 **Web 服务器监听的端⼝**（HTTP 默认端⼝号是 `80` ， HTTPS 默认端⼝号是 `443` ）

在双⽅建⽴了连接后，**TCP 报⽂中的数据部分就是存放 HTTP 头部 + 数据**，组装好 TCP 报⽂之后，就需交给下⾯的⽹络层处理

⾄此，⽹络包的报⽂如下图

![[Drawing 2024-08-02 23.01.20.excalidraw|900]]

### 网络层协议

TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象。

#### IP 协议

我们先看看 IP 报⽂头部的格式

![[Drawing 2024-08-02 23.17.24.excalidraw|900]]


在 IP 协议⾥⾯需要有 **源地址 IP** 和 **⽬标地址 IP**：
+ 源地址IP，即是客户端输出的 IP 地址；
+ ⽬标地址，即通过 DNS 域名解析得到的 Web 服务器 IP

如果数据经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 `0x06` （⼗六进制），表示协议为 TCP

> 假设客户端有多个⽹卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？

当存在多个⽹卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块⽹卡中判断应该使⽤哪个⼀块⽹卡来发送包。这个时候就需要根据 **路由表** 规则，来判断哪⼀个⽹卡作为源地址 IP

⾄此，⽹络包的报⽂如下图。

![[Drawing 2024-08-02 23.30.21.excalidraw|900]]

### 以太网

⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 **MAC 头部**

#### MAC 包头格式

MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息。

![[Drawing 2024-08-02 23.36.45.excalidraw|900]]
 
在 MAC 包头⾥需要 **发送⽅ MAC 地址** 和 **接收⽅⽬标 MAC 地址**，⽤于 **两点之间的传输**。

⼀般在 TCP/IP 通信⾥，MAC 包头的协议类型只使⽤

+ `0x0800`  ： IP 协议
+ `0x0806`  ： ARP 协议

#### 获取 MAC 地址

**发送⽅** 的 MAC 地址获取就⽐较简单了，MAC 地址是在⽹卡⽣产时写⼊到 ROM ⾥的，只要将这个值读取出来写⼊到 MAC 头部就可以了。

**接收⽅** 的 MAC 地址就有点复杂了，只要告诉以太⽹对⽅的 MAC 的地址，以太⽹就会帮我们把包发送过去，那么很显然这⾥应该填写对⽅的 MAC 地址

所以先得搞清楚应该把包发给谁，这个只要查⼀下 **路由表** 就知道了。在路由表中找到相匹配的条⽬，然后把包发给 Gateway  列中的 IP 地址就可以了。

既然知道要发给谁，按如何获取对⽅的 MAC 地址呢？不知道对⽅ MAC 地址？在以太网中，**不知道就喊呗**。此时就需要 ARP  协议帮我们找到路由器的 MAC 地址。

![[Pasted image 20240802234301.png|900]]

ARP 协议会在以太⽹中以 **⼴播** 的形式，对以太⽹所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。然后就会有⼈回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

如果对⽅和⾃⼰处于同⼀个⼦⽹中，那么通过上⾯的操作就可以得到对⽅的 MAC 地址。然后，我们将这个 MAC 地址写⼊ MAC 头部，MAC 头部就完成了

⾄此，⽹络包的报⽂如下图。

![[Drawing 2024-08-02 23.44.15.excalidraw|900]]

### 网卡

⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此，我们需要将 **数字信息转换为电信号**，才能在⽹线上传输，也就是说，这才是真正的数据发送过程。

负责执⾏这⼀操作的是 **⽹卡**，要控制⽹卡还需要靠 **⽹卡驱动程序**。

⽹卡驱动获取⽹络包之后，会将其 **复制** 到 **⽹卡内的缓存区** 中，接着会 **在其开头加上 _报头和起始帧_ 分界符**，在 **末尾加上⽤于 _检测错误的帧校验序列_**。

![[Pasted image 20240802235002.png|900]]

最后⽹卡会将包转为电信号，通过⽹线发送出去
