# 算法复杂度

**算法** 是为求解一个问题需要遵循的、_被清楚指定_ 的简单 **指令集合**。对于一个问题，一旦给定了某种算法，并且确定其是正确的，那么重要的是确定 **该算法需要的时间或空间资源** 的问题。

**_算法复杂度_** 指的是指 _算法解决问题所需的 **计算资源**_。这些计算资源可以是 **程序执行所花费的时间(_时间复杂度_)**，也可以是 **程序执行过程中内存使用的空间(_空间复杂度_)**
+ 如果一个算法需要一年的时间，那么这个算法就很难有什么用处
+ 同样，一个算法需要高达 `1GB` 的内存，在打多数机器上是无法运行的

> [!tip] 算法设计的目的
> 
> 目的是 **最大限度地减少这些资源**，因此花费更少时间和空间的算法被认为更有效

如何分析一个算法需要的时间复杂度和空间复杂度呢？下面我们开始学习算法分析

## 渐进符号定义

估计算法资源消耗所需的分析一般来说是一个理论问题，需要一套正式的数学模型框架。算法分析围绕着下面 $4$ 个定义：这些定义在函数之间建立了一种相对的级别。给定两个函数 $f(N)$ 和 $g(N)$，我们并不关系 $f(N) \lt g(N)$ 这样的关系。我们关心的是这两个函数的 **_相对增长率_**

> [!tip] 算法复杂性基础定义 
> 
> 定义1：如果存在常数 $c \gt 0$ 和 $n_0$，当 $N \ge n_0$ 时 $T(N) \le cf(N)$，则记为 $T(N) = O(f(N))$
> + $T(N)$ 的增长率小于等于 $f(N)$。即 $f(N)$ 是 $T(N)$ 的上界
> 
> 定义2：如果存在常数 $c \gt 0$ 和 $n_0$，当 $N \ge n_0$ 时 $T(N) \ge cg(N)$，则记为 $T(N) = \Omega(g(N))$
> + $T(n)$ 的增长率大于等于 $g(N)$。即 $T(n)$ 是 $g(N)$ 的下界
> 
> 定义3：当且仅当 $T(N) = O(h(N))$ 且 $T(N) = \Omega(h(N))$ 时，$T(N) = \Theta(h(N))$
> + $T(N)$ 的增长率等于 $h(N)$
> 
> 定义4：如果 $T(N) = O(p(N))$ 且 $T(N) \ne \Theta(p(n))$，则 $T(N) = o(P(N))$
> + $T(N)$ 的增长率小于 $p(N)$

例如，$N$ 较小时 $1000N$要比 $N^2$ 大，但所 $N^2$ 以更快的速度增长，因此 $N^2$ 最终将更大。根据定义1，最后总会存在某个点 $n_0$，从它以后 $cf(n)$ 总是至少与 $T(N)$ 一样大，忽略常数因子，$f(N)$ 至少与 $T(N)$ 一样大。本例中 $T(N) = 1000N, f(N) = N^2$。因此，可以说 $1000N = O(N^2)$。这种称为 **_大 O 记法_**

$N^3$ 增长的比 $N^2$ 快，因此可以说 $N^2 = O(N^2)$ 或则 $N^3 = \Omega(N^2)$。$f(N)=N^2$ 和 $g(N)=2N^2$ 以相同的速率增长，从而 $f(N) = O(g(N))$ 和 $f(N) = \Omega(g(N))$；两个函数以相同速率时，可以使用 $\Theta(\cdot)$ 记号

> [!tip] 计算复杂度的一些重要结论
> 
> 如果 $T_1(N) = O(f(N))$ 且 $T_2(N) =O(g(N))$，那么
> + $T_1(N) + T_2(N) = \max\{O(f(N)), O(g(N))\}$
> + $T_1(N) \times T_2(N) = O(f(N) \times g(N))$
> 
> 如果 $T(N)$ 时一个 $k$ 次多项式，则 $T(N) = O(N^k)$
> 
> 对于任意常数 $k$，$\log^k N = O(N)$，即对数增长非常迟缓

### 典型的增长率

随着输入数据规模 $N$ 的增加，一些典型的增长率用于量化算法的性能。它们通常用 大 O 表示法表示，例如：

**$O(1)$：恒定的增长率**，无论输入数据集的规模是多少，算法消耗的资源总是相同的
+ 通过索引访问数组中的任何元素都是 $O(1)$ 操作，因为无论元素在数组中的位置如何，访问操作都需要相同的时间

**$O(\log N)$：对数增长率**，随着输入数据集的规模变化，算法消耗的资源呈对数增长
+ 例如，二分查找是对数时间复杂度的典型示例，算法在每一步将列表分成两半，直到找到所需的元素

**$O(N)$：线性增长率**，随着输入数据的规模变化，算法消耗的资源呈线性增长 
+ 这意味着如果将输入大小加倍，运行时间最多也会加倍。在理想情况下，数据集中的每个元素都应该被查看一次
+ 例如，计数排序、桶排序等排序算法在一定条件下具有线性时间复杂度

**$O(N \log N)$：拟线性时间复杂度**，比线性稍差，但比多项式好

**$O(N^2)$：平方级增长率**，随着输入数据的规模变化，呈平方级增加

**$O(N^3)$：立方级增长率**，随着输入数据的规模变化，呈立方级增加

**$O(2^N)$ 和 $O(N!)$：分别为指数和阶乘增长率**，随着输入的规模的变化，增长得非常快


## 时间复杂度的估计

下面讨论的一般时间复杂度的估计

### 循环

**循环**：一次循环运行的时间至多是该 **循环内语句(包括测试)的运行时间乘以循环次数**

**嵌套循环**：从里向外分析这些循环。**在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有循环的循环次数**

下面程序片段的运行时间为 $O(N^2)$
```go
for i:= 0; i < N; i++ {
	for j := 0; j < N; j++ {
		k++  // 执行 1 次
	} // 迭代 N 次
}// 迭代 N 次
```

### 顺序

将各个语句的运行时间求和即可：**这意味着最大值就是运行时间**。下面的程序片段中，先用去 $O(N)$，再花销 $O(N^2)$，因此总开销为 $O(N^2)$

```go
for i := 0; i < N; i++ {
	A[i] = 0 // 执行 1 次
}// 迭代 N 次

for i:= 0; i < N; i++ {
	for j := 0; j < N; j++ {
		A[i] += A[j] + i + j  // 执行 1 次
	} // 迭代 N 次
} // 迭代 N 次
```

### 分支

对于分支语句，运行时间不超过判断时间加上分支中最长的时间的总和

> [!tip] 某些情形估计过高，但绝不会估计过低
> 
> 另可估计过多，也不要估计过少

### 递归

如果递归只是稍加掩饰的循环，分析通常比较简单。例如

```go
func Factorial(n int) int {
	if n <= 1 {
		return 1
	}
	return n * Factorial(n-1)
}
```

将递归转换为循环可能不是非常容易的。例如

```go
func Fib(n int) int {

	if n <= 1 {
		return 1
	}

	return Fib(n-1) + Fib(n-2)
}
```

这个递归的分析比较困难。需要按照递归写出递推公式

$$
T(N) = \begin{cases} 1 & N=0, 1 \\ T(N-1) + T(N-2) + 2 & N \ge 2 \end{cases}
$$
