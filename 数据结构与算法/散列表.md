# 散列表

散列表也称 **哈希表**，Go 提供了其默认实现，即 [[哈希表]]，其中简单介绍了哈希表的原理。现在，我们来详细讨论哈希表的原理

散列表就是一个含有 **关键字** 的具有 **固定大小** 的顺序表

> [!tip] 关键字
> 关键字就算一个带有相关值的字符串，称为 `key`

> [!tip] 表大小
> 线性表的长度称为表大小，即为 `size`

索引 `0 ... size-1` 可以直接访问顺序表。通过一个函数将 `key` 映射到 `0 ... size-1` 范围内的某个索引，并且将 `key` 放入适当的单元中

> [!tip] 散列函数
>
> 将 `key` 映射到 `0 ... size-1` 范围内的函数成为 **散列函数**
> 
> 一个理想的散列函数可以保证将两个不同的 `key` 映射到不同的单元。然而，`key` 可能是无穷无尽的。因此，**散列函数应该尽可能的在单元之间均匀分配关键字**

> [!tip] 散列冲突
> 
> 当两个 **不同关键字的散列值相等** 时，称为散列冲突

下图描述了一个理想状态下的散列表

![[Drawing 2024-06-25 14.35.46.excalidraw|900]]

`john` 被散列到 `3`，`phl` 被散列到 `4`，`dave` 被散列到 `6`，`mary` 被散列到头来 `7`

> [!important] 散列表：一种存储 `key-value` 对的数据结构
>
 > 散列表是如何存储 `key-value` 对的呢？
 > 
> 散列表一般是使用长度 $m$ 顺序表来存储。顺序表的每个位置可以称为一个 **桶**，这些桶都有一个编号 `[0, m - 1]`。
> 
> 首先，通过 **_散列函数_** `Hash()` 将 `Key` 处理一下，得到一个哈希值 `hash`。然后，使用这个 `hash` 值从编号为 `[0, m-1]` 的桶中选择一个
> 
> 选择桶常用方法有两种：**取模法** 和 **位与**
> 
> + 取模法：让这个哈希值 `hash`  与 `m` 取模(`hash % m`)，得到一个桶编号
> + 位与：让这个哈希值 `hash` 与 `m-1` 进行位与 (`hash & (m-1)`)，得到一个桶编号。这里 `m` 必须是 `2 ^ n`，这样才能保证 `hash & (m-1)` 的结果落在 `[0, m-1]` 之间
> 	+ 理由参见 [[栈和队列#^36807a|位与替换取模运算]]
> 
> 如果 _两个不同的关键字选择了相同的桶_，那么就出现了 **_哈希冲突_**。有多种解决哈希冲突的方法：**_拉链法_**、**_开放地址法_** 和 **_再散列_**

### 散列函数

参考： [Python 数字类型的哈希运算](https://docs.python.org/zh-cn/3/library/stdtypes.html#hashing-of-numeric-types)

如果输入的关键字 `key` 是整数，则一般且合理的方法就算直接返回 `key mod size`

> [!question] `size` 的不当选择，会导致大量的 `key` 被散列到同一个位置(哈希冲突)
> 
> 如果 `size` 为 $10$ 并且 `key` 都是以 $0$ 为个为，则 `key mod size` 散列函数将 `key` 全部散列到了一个位置

为了避免哈希冲突，通常是保证 `size` 是一个 **_素数_**。当输入的关键字是随机整数时，这个散列函数不仅计算简单，并且分配也很均匀

---

通常，关键字是字符；在这种情况下，哈希函数需要仔细选择

**编码值直接相加**：把字符串中的字符 **编码值** 加起来

```go
type Index = int

func Hash(s string) (hashValue Index) {

	for _, ch := range s {
		hashValue += Index(ch)
	}
	return hashValue
}
```

> [!check] 如果表很大，关键字很短，则该函数将不会很好的分配关键字
> 
> 设 `size = 10007`，并设所有的 `key` 至多 $8$ 个字符长。如果 `key` 中的字符采用 ASCII 编码，此散列函数只能假设值在 $0$ 和 $1016$ 之间，其中 $1016 = 127 \times 8$
> 
> 显然，这不是一种均匀分配


**只使用三个字符**： 假设 `key` 至少有 $3$ 个字符，下列函数只考虑了前 $3$ 个字母

```go
type Index = int

func Hash(s string) (hashValue Index) {
	hashValue = Index(s[0]) + 27*Index(s[1]) + 729*Index(s[2])
	return hashValue
}
```
+ $27$ 表示 $26$ 个字母外加空格
+ $729$ 表示 $26^2$

> [!check] 这个要求前 $3$ 个字母是随机的
> 由于英文不是随机的。$3$ 个字母的不同组合实际只有 $2851$ 种。即使这些组合没有冲突，也不过只有表的 $28\%$，这里假设 `size = 10007`


**Horner 法则**：计算 $\sum_{i=0}^{\text{KeySize}-1} \text{Key}[\text{KeySize }- i -1] * 32^i$, 并将结果限制在适当的范围内。这个公式涉及到关键字中的 **所有字符串**，并且可以分布的很好

```go
type Index = int

func Hash(s string) (hashValue Index) {

	for _, ch := range s {
		hashValue = (hashValue << 5) + Index(ch)
	}
	return hashValue
}
```

程序根据 `Horner` 法则计算一个 ($32$ 的) 多项式函数。例如，计算 $h_k = k_1 + 27 k_2 + 27^2k_3$ 的另一种方式是借助于公式 $h_k = ((k_3) \times 27 + k_2) \times 27 + k_1$ 进行。`Horner` 发展将其扩展到用于 $n$ 次多项式

使用 $32$ 代替 $27$ 是因为用 $32$ 作乘法不是真的乘，而是移动二进制的 $5$ 位。为了加速，在程序的第 $6$ 行的加法可以用按位异或来代替

散列函数确定之后，考虑解决冲突的问题。当一个元素被插入处另一个元素已经存在（散列值相同），那么就产生一个冲突，这个冲突需要消除。解决冲突的方法最简单的就算 **_分离链接法_** 和 **_开放定址法_**

## 分离链接法

解决冲突的第一种方法叫做 **分离链接法**：就是 **将散列到同一值的所有元素保留到一个表中**。为了方便，这些表都有一个表头。如果空间紧张，则可以以避免使用表头。假设关键字是前 $10$ 个完全平方数并设散列函数就是 $Hash(X) = X \mod{10}$。表大小(`size`) 不是素数，下图清晰展示了分离链接法

![[Drawing 2024-06-25 14.45.54.excalidraw|900]]

### 类型声明

显然，这里需要使用到链表。因此，使用分离链接法实现的哈希表的类型声明如下

```go
package hash

type node struct {
	value interface{}
	next  *node
}

type hashTable struct {
	data []*node
	size int
}

func New(size int) *hashTable {
	return &hashTable{
		data: make([]*node, size),
		size: size,
	}
}
```

### 插入


如果要插入的项已经存在，那么我们就什么也不做；否则我们把它放在链表的前端。插入项可以放在任何位置，放在前段可以做到 $O(1)$ 插入

```go
func (ht *hashTable) Insert(key string, value interface{}) *hashTable {

	hashValue := hash(key)

	index := hashValue % ht.size

	newNode := &node{
		key:   key,
		value: value,
		next:  nil,
	}

	// 哈希冲突
	if ht.data[index] != nil {
		// 修改值
		if ht.data[index].key == key && ht.data[index].value != value {
			ht.data[index].value = value
			return ht
		}
		// 链表头插法
		newNode.next = ht.data[index]
		ht.data[index] = newNode
	} else {
		ht.data[index] = newNode
	}

	ht.len++
	return ht
}
```

### 删除

删除元素是链表的直接实现

```go
func (ht *hashTable) Delete(key string) (value interface{}) {
	hashValue := hash(key)

	index := hashValue % ht.size

	if ht.data[index] != nil {
		pre := (*node)(nil)
		cur := ht.data[index]

		for cur != nil && cur.key != key {
			pre = cur
			cur = cur.next
		}

		if cur != nil {
			value = cur.value

			// 删除第一个结点
			if pre == nil {
				ht.data[index] = cur.next
			} else {
				// 中间结点
				pre.next = cur.next
			}
			ht.len--
		}
	}
	return
}
```

解决拉链法解决冲突，可以使用后面介绍的 [[树与二叉树#二叉查找树]]  或者 [[树与二叉树#AVL树]] 等

### 装填因子

散列表的 **装填因子$\lambda$** 定义如下

$$
\lambda = \frac{\text{len}}{\text{size}}
$$

+ $\text{len}$：表示散列表中元素的个数
+ $\text{size}$：表示散列表的容量

表的平均长度为 $\lambda$ 执行一次查找需要的时间($\text{T}$) 就算计算散列函数值需要的常数时间($\text{t}_1$)加上遍历表的时间($\text{t}_2$)

$$
\text{T} = \text{t}_1 + \text{t}_2
$$

在一次 _不成功的查找_ 中，遍历链接数平均为 $\lambda$。_成功的查找_ 则需要遍历大约 $1 + \frac{\lambda}{2}$ 个链接；它保证必然会遍历一个链接(因为查找是成功的)，而我们也期望沿着一个表中途就能找到匹配的元素

> [!tip] 表大小不重要，重要的时装填因子
> 分离链接散列表的一般法则是使得表大的大小尽量与预料的元素个数差不多

## 开放定址法

> [!tip] 分离链接法的缺点
> + 需要指针，由于给新单元分配地址需要时间，因此导致算法的速度减慢
> + 算法实际上还要求实现另一个数据结构

开放定址散列法是另一种用链表解决冲突的方法。在开放地址散列算法中，如果 **发生冲突**，那么就尝试 **选择另外的单元**，直到找出空的单元地址。

更一般的，单元 $h_0(key), h_1(key), \cdots$ 相继被尝试，其中 $h_i(key) = (Hash(key) + F(i)) \mod size$，且 $F(0) = 0$。函数 $F(i)$ 就算冲突解决方法。

开放地址散列需要的表比分离链接法散列用的表大。一般而言，开放地址散列算法要求装填因子应该低于 $0.5$，即 $\lambda \le 0.5$

### 线性探测

线性探测法中，函数 $F(i)$ 是线性函数，典型情况是 $F(i) = i$。这就相当于逐个探测每个单元以查找下一个空单元。下表展示了插入关键字 $\{89, 18, 49, 58, 69\}$ 使用 $F(i) = i$ 解决冲突的情况。
+ 最开始为空表。当插入第一个关键字 $89$，选择的索引是 $(89 \mod 10 + F(0))\mod 10 = 9$，该索引没有被占用，因此 $89$ 就插入在索引 $9$ 的位置
+ 插入第二个关键字 $18$，线性探测索引为 $(18 \mod 10 + F(0)) \mod 10 = 8$，该索引依旧没有匾额占用，因此 $18$ 就插入索引为 $8$ 的位置
+ 插入第三个关键字 $49$，线性探测索引为 $(49 \mod 10 + F(0))\mod 10 = 9$，该索引被占用，继续探测 $(49 \mod 10 + F(1))\mod 10 = 0$，索引 $0$ 没有被占用，因此 $49$ 就插入到索引 $0$ 的位置
+ 插入第四个关键字 $58$，线性探测索引为 $(58 \mod 10 + F(0)) \mod 10 = 8$，被占用；
	+ 继续探测 $(58 \mod 10 + F(1))\mod 10 = 9$，被占用；
	+ 继续探测  $(58 \mod 10 + F(2))\mod 10 = 0$，被占用；
	+ 继续探测  $(58 \mod 10 + F(3))\mod 10 = 1$，没有被占用。
+ 插入最后一个关键字 $69$，线性探测索引为 $(69 \mod 10 + F(3)) \mod 10 = 2$

| 索引  | 空表  | 插入 $89$ | 插入 $18$ | 插入 $49$ | 插入 $58$ | 插入 $69$ |
| :-: | :-: | :-----: | :-----: | :-----: | :-----: | :-----: |
|  0  |     |         |         |   49    |   49    |   49    |
|  1  |     |         |         |         |   58    |   58    |
|  2  |     |         |         |         |         |   69    |
|  3  |     |         |         |         |         |         |
|  4  |     |         |         |         |         |         |
|  5  |     |         |         |         |         |         |
|  6  |     |         |         |         |         |         |
|  7  |     |         |         |         |         |         |
|  8  |     |         |   18    |   18    |   18    |   18    |
|  9  |     |   89    |   89    |   89    |   89    |   89    |

只要表足够大，总能找到一个自由单元，但是花费的时间也是较多的。更糟糕的是 **一次聚集** 问题

> [!tip] 一次聚集
> 线性探测解决冲突问题时，因为 **_冲突选择的单元会形成一些区块_**，其结果称为 **_一次聚集_**。
> 
> **散列到聚集区域的任何关键字都需要多次试选才能解决冲突**，然后该关键字被添加到相应的聚集区域

使用线性探测的预期探测次数对于插入和不成功的查找来说大约为 $\frac{1}{2}\left(\frac{1+1}{(1-\lambda)^2}\right)$，对于成功的查找来说则是 $\frac{1}{2}\left( \frac{1+1}{1-\lambda} \right)$

### 平方探测

平方探测是消除一次聚集问题的冲突解决方法。平方探测的冲突解决函数为二次汉斯，通常选择 $F(i) = i^2$。下表展示了插入关键字 $\{89, 18, 49, 58, 69\}$ 使用 $F(i) = i^2$ 解决冲突的情况。
+ 最开始为空表。当插入第一个关键字 $89$，选择的索引是 $(89 \mod 10 + F(0))\mod 10 = 9$，该索引没有被占用，因此 $89$ 就插入在索引 $9$ 的位置
+ 插入第二个关键字 $18$，线性探测索引为 $(18 \mod 10 + F(0)) \mod 10 = 8$，该索引依旧没有匾额占用，因此 $18$ 就插入索引为 $8$ 的位置
+ 插入第三个关键字 $49$，线性探测索引为 $(49 \mod 10 + F(0))\mod 10 = 9$，该索引被占用，继续探测 $(49 \mod 10 + F(1))\mod 10 = 0$，索引 $0$ 没有被占用，因此 $49$ 就插入到索引 $0$ 的位置
+ 插入第四个关键字 $58$，线性探测索引为 $(58 \mod 10 + F(0)) \mod 10 = 8$，被占用；
	+ 继续探测 $(58 \mod 10 + F(1))\mod 10 = 9$，被占用；
	+ 继续探测  $(58 \mod 10 + F(2))\mod 10 = 2$，没有被占用；
+ 插入最后一个关键字 $69$，线性探测索引为 $(69 \mod 10 + F(2)) \mod 10 = 3$

| 索引  | 空表  | 插入 $89$ | 插入 $18$ | 插入 $49$ | 插入 $58$ | 插入 $69$ |
| :-: | :-: | :-----: | :-----: | :-----: | :-----: | :-----: |
|  0  |     |         |         |   49    |   49    |   49    |
|  1  |     |         |         |         |         |         |
|  2  |     |         |         |         |   58    |   58    |
|  3  |     |         |         |         |         |   69    |
|  4  |     |         |         |         |         |         |
|  5  |     |         |         |         |         |         |
|  6  |     |         |         |         |         |         |
|  7  |     |         |         |         |         |         |
|  8  |     |         |   18    |   18    |   18    |   18    |
|  9  |     |   89    |   89    |   89    |   89    |   89    |

> [!tip] 定理：如果使用平方探测，且表大小是素数，那么当表至少有一半是空的时候，总能插入一个新的元素

#### 类型定义

```go

type status uint8

const (
	empty      status = iota // 空单元
	deleted                  // 被删除，执行懒惰删除
	legitimate               // 合法值
)

type node struct {
	key    string
	value  interface{}
	status status
}

type hashTable struct {
	data []node
	size int
	len  int
}

func New(size int) *hashTable {
	result := &hashTable{
		data: make([]node, size),
		size: size,
		len:  0,
	}

	for i := 0; i < result.size; i++ {
		result.data[i].status = empty
	}

	return result
}
```

开放定址散列中，标准的删除操作是不能执行的，因为相应的单元可能已经引起过冲突，元素绕过它存在了别处。因此，开放地址散列需要 **懒惰删除**

> [!tip] 懒惰删除
> 使用一个标志位，标记元素是否被删除

#### 查找

`Find(key)` 将返回 `key` 在散列表中的位置。如果 `key` 不存在，那么 `Find` 返回最后的单元。该单元就是当需要时插入的地方

```go
func (ht *hashTable) Find(key string) interface{} {
	hashValue := Hash(key)
	currentIndex := hashValue % ht.size

	collisionNumber := 0 // 碰撞次数

	// 不是空，key 不同
	for ht.data[currentIndex].status != empty && ht.data[currentIndex].key != key {
		collisionNumber++

		// F(i) = i ^ 2 = (i - 1) ^ 2 + 2i - 1 = F(i-1) + 2i - 1
		currentIndex += 2*collisionNumber - 1

		if currentIndex >= ht.size {
			currentIndex -= ht.size
		}
	}
	return currentIndex

}
```

#### 插入

如果 `key` 存在，并且 `value` 不同，就覆盖原有的 `value`

```go
func (ht *hashTable) Insert(key string, value interface{}) *hashTable {

	index, _ := ht.Find(key)

	newNode := node{
		key:    key,
		value:  value,
		status: legitimate,
	}

	if ht.data[index].status != legitimate {
		ht.data[index] = newNode
	}
	ht.len++
	return ht
}
```

#### 删除

只是将 `key` 标记为 `deleted`

```go
func (ht *hashTable) Delete(key string) *hashTable {

	index, value := ht.Find(key)

	if value == nil {
		return ht
	}

	ht.data[index].status = deleted
	ht.len--
	return ht
}
```

### 双散列

双散列也是解决冲突的一种方法。对于双散列，通常选择 $F(i) = i \times Hash_2(key)$。关于 $Hash_2(key)$ 的选择也需要认真考虑。通常选择 $Hash_2(key) = R - (Hash(key) \mod R)$。$R$ 是小于 `size` 的素数
