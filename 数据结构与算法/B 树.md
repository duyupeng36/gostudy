# B 树

B 树是一种 **_自平衡_** 查找树，维护已排序的数据并允许高效地进行插入、删除和搜索操作

B 树的主要特征是 _所有叶子节点都在同一级别_，并且内部节点可以存储多个键。B 树中的每个节点都包含一定数量的键和指针，用于导航树。键充当分隔值，用于划分其子树

> [!example] 
> 如果一个节点包含值 `[10,20,30]`，则它有四个子节点
> + 第一个包含小于 10 的值
> + 第二个包含 10 到 20 之间的值
> + 第三个包含 20 到 30 之间的值
> + 第四个包含大于 30 的值

> [!tip] B树的阶
> 内部节点的子树的 _最多数目_ 称为 B 树的 **阶**

> [!tip] B 树的结构性：阶为 $M$  的 B 树是一颗具有如下结构特性的树
> + 树的根：或者是一片树叶，或者其儿子数在 $2$ 到 $M$ 之间
> + 除根外，所有非树叶节点的儿子树在 $\lceil M / 2 \rceil$ 和 $M$ 之间
> + 所有的树叶都在相同的深度
> 

> [!tip] $M$ 阶 B 树的存储
>  
> 所有的数据都在树叶上
> 
> 每一个内部节点上皆有指向该节点各个儿子的指针 $P_1,P_2,\cdots, P_M$ 和分别代表 $P_2, P3,\cdots, P_M$ 上发现的最小值
>
>有些指针可能是 `NULL` ，而且对应的 $k_i$ 则是未定义的
>
>对于每一个节点，其子树 $P_1$ 中的所有关键字小于子树 $P_2$ 的关键字，$P_2$ 中的所有关键字小于子树 $P_3$，等等
>
>**_叶子节点包含所有的实际数据_**，这些数据或者是关键字本身，或者是指向含有这些关键字的记录的指针
>
>额外的要求：在树叶中关键个数也在 $\lceil M/2 \rceil$ 和 $M$之间

下图是一棵 $4$ 阶 B 树的例子

![[Drawing 2024-07-30 18.50.04.excalidraw|900]]

$4$ 阶 B 树也称为 $2-3-4$树，$3$ 阶 B 树叫做 $2-3$树。下面我们同 $2-3$树的特殊情形来描述 B 树的操作

## 操作

现在从下面的 $2-3$树开始

![[Drawing 2024-07-31 10.44.21.excalidraw|900]]

> [!tip] 结构
> 内部节点画为椭圆，每个节点含有两个数据。短横线表示呢不的第二个信息，表明他只有两个儿子
> 
> 树叶用画为方形，内含有关键字。**树叶中的关键字是有序的**

### Find

为了执行一次 `Find`，从根出发并根据要查找的关键字与存储在节点上的两个值之间的关系确定三个方向中的一个方形。下图展示了查找 $31$ 的过程

![[Drawing 2024-07-31 10.59.45.excalidraw|900]]

### Insert

为了对一个尚未出现的关键字 $X$ 执行一次 `Insert`。首先，按执行 `Find` 的步骤进行，当到达一片树叶时，就找到了插入 $X$ 的正确位置

首先，从根开始查找关键字应该插入的叶子节点。如果把它加到一片树叶上而不破坏 $2-3$树性质，那么插入完成。例如，要插入关键字 $18$ 后的结果如下图

![[Drawing 2024-07-31 12.57.38.excalidraw|900]]

由于一片树叶只能容纳 $2\sim 3$ 个关键字。因此，某些插入会存在问题。例如，想要将关键字 $1$ 插入到 $2-3$树中，发现 $1$ 属于的节点已经满了，如下图，这样的插入是不允许的

![[Drawing 2024-07-31 13.18.14.excalidraw|900]]

解决该问题的方法很是很明显的。**只需要将叶子节点分裂为两个节点**，每个节点包含两个关键字。同时，调整它们的父节点的信息

![[Drawing 2024-07-31 13.21.23.excalidraw|900]]

继续插入 $19$ 。又会出现另一个问题，子节点分裂后，起父节点无法再存储子节点

![[Drawing 2024-07-31 13.28.13.excalidraw|900]]

因为内部节点只允许 $3$ 个子节点，插入 $19$ 导致一个内部节点变成了的儿子变成了 $4$ 个从而导致插入失败。解决方法就是**将内部节点分裂为两个内部节点**。

![[Drawing 2024-07-31 13.31.53.excalidraw|900]]

> [!tip] 节点分裂可以持续到根节点
> 分裂节点将给他的父节点带来一个新问题，该节点的父节点可能会有 $4$ 个儿子，这样就需要继续向上分裂，直到或者到达跟节点，或者找到一个只有 $2$ 个儿子的节点

现在，插入关键字 $28$，那么就会出现一片具有$4$ 个儿子的节点

![[Drawing 2024-07-31 13.36.54.excalidraw|900]]

那么该节点就会分裂成两个节点，每个节点有 $2$ 个儿子

![[Drawing 2024-07-31 13.40.10.excalidraw|900]]

此时，又产生了一个具有 $4$ 个儿子的内部节点，此时继续将他分裂为两个节点

![[Drawing 2024-07-31 13.41.20.excalidraw|900]]


> [!tip]
> 对于一般的 $M$ 阶 B 树，当插入一个关键字时，唯一的困难发生接收在该关键字的节点已经具有 $M$ 个关键字的时候
> 
> 插入这个关键字使得该节点具有 $M+1$ 个关键字，这样就必须把这个节点分裂为两个节点，他们分别具有 $\lceil (M+1) / 2 \rceil$ 个 和 $\lfloor (M+1)/2 \rfloor$ 个关键字
> 
> 由于节点分裂导致起父节点多出一个儿子，因此必须检查该节点的父节点能否接受多出来的儿子，如果父节点已经具有 $M$ 个儿子，那么父节点就必须分裂成两个节点
> 
> 重复上述过程直到找到一个具有少于 $M$ 个儿子的父节点
> 
> 如果分裂根节点，那么我们就要创建一个新的根，这个根有两个儿子（导致 B 树的层数加 $1$）

### Delete

`Delete` 操作可以看作 `Insert` 的逆操作。通过查找要删除的关键字并将其除去而完成删除操作

如果这个关键字是一个节点仅有的两个关键字之一，那么将他除去后就剩一个关键字了。此时，可以将他与兄弟合并；如果兄弟已有 $3$ 个关键字，那么就将兄弟中的一个关键字抢过来，使得两个节点各有 $2$ 个关键字

## 分析

B 的深度最多是 $\lceil \log_{\lceil M / 2 \rceil} N \rceil$。在路径上的每个节点，执行 $O(\log M)$ 的工作量选择哪个分支（二分查找），但是 `Insert` 和 `Delete` 可能需要 $O(M)$ 的工作量来调整该节点上的所有信息

对于每个 `Insert` 和 `Delete` 运算，最坏情形的运行时间为 $O(M \log_M N) = O((M/ \log M) \log N)$。

一次 `Find` 只花费 $O(\log N)$ 时间

> [!tip] $M$  最好的选择是 $M=3$ 或者 $M=4$
