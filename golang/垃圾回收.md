# 垃圾回收

> [!quote] 版权声明
> 本节为 CSDN 博主「我是小道哥」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
> 原文链接：[https://blog.csdn.net/xiaodaoge_it/article/details/121890145](https://blog.csdn.net/xiaodaoge_it/article/details/121890145)

**垃圾回收（Garbage Collection，缩写为GC）**，是一种自动内存管理机制

> 即我们在程序中定义一个变量后，会在内存中开辟相应空间进行存储。当不需要此变量后，需要手动销毁此对象，并释放内存。而这种 **对不再使用的内存资源进行自动回收的功能即为垃圾回收**

> [!important] Go 对象的 声明周期完全由 GC 管理，因此，Go 函数 _返回局部变量的指针是合法的_
> + 注意，与其他语言的区分，例如，C 语言是不能返回局部变量的指针

垃圾回收的相关术语：
+ **赋值器:** 说白了就是你写的程序代码，在程序的执行过程中，可能会改变对象的引用关系，或者创建新的引用。
+ **回收器:** 垃圾回收器的责任就是去干掉那些程序中不再被引用得对象
+ **STW:** 全称是 `Stop The World`，GC期间某个阶段会 **停止所有的赋值器，中断你的程序逻辑，以确定引用关系**
+ **root对象:** 根对象是指 **赋值器不需要通过其他对象就可以直接访问到的对象**，通过 `root` 对象, 可以追踪到其他存活的对象。常见的 `root` 对象有：
	+ **全局变量**：程序在编译期就能确定的那些 **存在于程序整个生命周期的变量**。
	+ **执行栈**：每个 `goroutine` (包括 `main` 函数)都拥有自己的执行栈，这些执行栈上包含 **_栈上的变量_ 及 _堆内存指针_**。【堆内存指针即在 `gorouine` 中 **申请或者引用了在堆内存的变量**】

## 标记-清除 Go <= 1.3

标记清除法主要包含两个步骤：
+ **标记**
+ **清除**

### 标记阶段

开启 STW，停止程序的运行，下图中是本次 GC 涉及到的 root 节点和相关对象。

![[Pasted image 20240703211029.png]]

**从根节点出发，标记所有可达对象**

![[Pasted image 20240703211055.png]]

### 清除

停止 STW，然后回收所有未被标记的对象

![[Pasted image 20240703211139.png]]

> [!hint] 标记清除法的 **最大弊端就是在整个 GC 期间需要 STW，将整个程序暂停。** 
> 因为如果不进行 STW 的话，会出现已 _经被标记的对象 A_，_引用了新的未被标记的对象 B_，但由于对象 A 已经标记过了，_不会再重新扫描 A 对 B 的可达性_，从而将 **B 对象当做垃圾回收掉**

说实话这种全程 STW 的 GC 算法真的是如过街老鼠，人见人打…好家伙，让我程序停下来，专门去做垃圾回收这件事，在追求高性能的今天，很难有人可以接受这种性能损耗。

所以 Golang 团队这个时期就开始专注于如何能提升 GC 的性能，Golang 团队对 GC 算法优化的方向是就是 **让 GC 和用户程序可以互不干扰，并发进行**。所以才有了后面的 **三色标记法**

## 三色标记法 Go >= 1.5

三色标记法

初始时，所有对象被标记为 **白色对象**

![[Pasted image 20240703211557.png]] 

遍历 rootset，将直接可达对象标记为 **灰色对象**（即，从白色对象集合中移除，然后加入到灰色对象集合）

![[Pasted image 20240703211755.png]]

遍历灰色对象集合，将直接可达的对象标记为为 **灰色对象**，自身标记为 **黑色对象**

![[Pasted image 20240703211853.png]]

重复，直到灰色对象集合为空

![[Pasted image 20240703211934.png]]

白色对象集合中剩余的即为 **不可达对象**，将白色对象回收

![[Pasted image 20240703212129.png]]

对于上述的三色标记法来讲, 仍然需要依赖 STW 的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。下面的示例场景

![[Pasted image 20240703212820.png]]

![[Pasted image 20240703212832.png]]

![[Pasted image 20240703212859.png]]

![[Pasted image 20240703212921.png]]

Golang 是如何解决这个 STW 问题的呢？其实总结来看，**在三色标记法的过程中对象丢失，需要同时满足下面两个条件**
+ 条件一：**白色对象被黑色对象引用**
+ 条件二：**灰色对象与白色对象之间的可达关系遭到破坏**

看来只要把上面两个条件破坏掉一个，就可以保证对象不丢失，所以 Golang 团队就提出了两种破坏条件的方式：**强三色不变式** 和 **弱三色不变式**

### 强三色不变式

> [!tip] 规则：**不允许黑色对象引用白色对象**

> 破坏了条件一： 白色对象被黑色对象引用
>
> 解释：如果一个黑色对象不直接引用白色对象，那么就不会出现白色对象扫描不到，从而被当做垃圾回收掉的尴尬

![[Pasted image 20240703213325.png]]

### 弱三色不变式

> [!tip] 规则：黑色对象可以引用白色对象，但是白色对象的上游必须存在灰色对象

> 破坏了条件二：灰色对象与白色对象之间的可达关系遭到破坏
>
> 解释： 如果一个白色对象的上游有灰色对象，则这个白色对象一定可以扫描到，从而不被回收

![[Pasted image 20240703213424.png]]

## 屏障机制

Golang团队遵循上述两种不变式提到的原则，分别提出了两种实现机制：**插入写屏障 和 删除写屏障**

##### 插入写屏障

> [!tip] **规则：** 当一个对象引用另外一个对象时，将另外一个对象标记为灰色

> 满足：强三色不变式。不会存在黑色对象引用白色对象

这里需要注意一点，**插入写屏障仅会在堆内存中生效**，不对栈内存空间生效，这是因为 Go 在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万 goroutine 的栈都进行屏障保护自然会有性能问题

下面我们看看插入写屏障机制，在插入写屏障机制下是如何保护对象不丢失的

![[Pasted image 20240703214105.png]]

![[Pasted image 20240703214119.png]]

![[Pasted image 20240703214135.png]]

可以发现，**对象3 在插入写屏障机制下，得到了保护**，但是 **由于栈上的对像没有插入写机制**，在扫描完成后，仍然可能存在栈上的白色对象被黑色对象引用，所以 **在最后需要对栈上的空间进行 STW**，防止对象误删除。如下所示

![[Pasted image 20240703214300.png]]

![[Pasted image 20240703214308.png]]

![[Pasted image 20240703214320.png]]

> [!warning] 对于插入写屏障来讲，插入写屏障最大的弊端就是，**在一次正常的三色标记流程结束后，需要对栈上重新进行一次 stw，然后再 rescan 一次**

##### 删除写屏障

> [!tip] **规则：** 在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。

> 满足弱三色不变式。灰色对象到白色对象的路径不会断
>
> **解释：** 白色对象始终会被灰色对象保护

下面我们看看在删除写屏障机制下是如何保护对象不丢失的

![[Pasted image 20240703214522.png]]

![[Pasted image 20240703214535.png]]

![[Pasted image 20240703214624.png]]

![[Pasted image 20240703214642.png]]

但是引入删除写屏障，有一个弊端，就是 **一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮**。如此一来，会产生很多的冗余扫描成本，且降低了回收精度，举例来讲

![[Pasted image 20240703214806.png]]

## 混合写屏障机制 Go >= 1.8 

混合屏障机制的核心定义：

+ **GC 刚开始的时候，会将栈上的可达对象全部标记为黑色。**
+ **GC 期间，任何在栈上新创建的对象，均为黑色。**


> **将栈上的可达对象全部标黑，最后无需对栈进行 STW，就可以保证栈上的对象不会丢失**。有人说，一直是黑色的对象，那么不就永远清除不掉了么，这里强调一下，**标记为黑色的是可达对象，不可达的对象一直会是白色**，直到最后被回收。

+ **堆上被删除的对象标记为灰色**
+ **堆上新添加的对象标记为灰色**

下面我们看看混合写屏障机制的示例图

![[Pasted image 20240703215216.png]]

![[Pasted image 20240703215233.png]]

![[Pasted image 20240703215242.png]]

![[Pasted image 20240703215303.png]]

![[Pasted image 20240703215320.png]]

![[Pasted image 20240704164124.png]]

> 问题：栈上的对象1 引用了堆上的对象8，由于不触发混合写屏障机制，那对象8一直是白色的，最后不就被垃圾回收走了么，谁来保护它？
>
> 这个情况是不会发生的，因为 **一个对象之所以可以引用另外一个对象，它的前提是需要另外一个对象可达**，图中的 8 号显然是不可达的，所以不会出现这种情况。
>
> 为什么 1号对象可以引用7号对象呢？这是因为1号对象在引用7号对象的时候，对象7是在对象6的下游，本身是可达。

![[Pasted image 20240703215511.png]]

> [!important] 总结
> + Golang v1.3 之前采用传统采取 标记-清除法，需要 STW，暂停整个程序的运行
> + 在 v1.5 版本中，引入了 **三色标记法** 和 **插入写屏障机制**，其中 **插入写屏障机制只在堆内存中生效**。但在标记过程中，**最后需要对栈进行 STW**
> + 在 v1.8 版本中结合删除写屏障机制，推出了 **混合屏障机制**，屏障限制只在堆内存中生效。避免了最后节点对栈进行 STW 的问题，提升了 GC 效率
