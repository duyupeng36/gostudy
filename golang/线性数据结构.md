什么是类型？计算机内存中保存的始终是 **位模式**。给定一个 $1$ 字节的位模式 `0x63`，它究竟代表什么是不可知的；它可能是整数、可能浮点数、还可能是字符

> [!important] 内存中保存的始终是位模式($0$ 和 $1$ 的序列)，相同序列可能代表了不同类型的数据
> - 另见 [[存储数据]]

本来 `0x63` 表示数字，但是文字必须编码成为 `0` 和 `1` 的序列，才能记录在计算机系统中。**在计算机世界里，一切都是数字，但是一定需要 _指定类型_ 才能正确的理解它的含义**

如果 `0x63` 是整数，它就属于整数类型，它是整数类型的一个具体的实例。整数类型就是一个抽象的概念，它是对一类有着共同特征的事物的抽象概念。它展示出来就是 `99`，因为多数情况下，程序按照人们习惯采用 $10$ 进制输出

如果 `0x63` 是 `byte` 类型或 `rune` 类型，在 Go 语言中，它是不同于整型的类型，但是展示出来同样是 `99`

如果 `0x63` 是 `string` 类型，则展示出一个字符的字符串 `"c"`

```go
package main

import "fmt"

func main() {

	var a = 0x63
	fmt.Printf("%T %d %c\n", a, a, a) // int 99 'c'

	var b byte = 0x63
	fmt.Printf("%T %d %c\n", b, b, b) // uint8  99 'c'

	var c rune = 0x63
	fmt.Printf("%T %d %c\n", c, c, c) // int32  99 'c'

	var d = "\x63"
	fmt.Printf("%T %s\n", d, d)         // string  "c"
	fmt.Printf("%T %s\n", a, string(a)) // int "c"
}
```

> [!summary] 类型只是应用程序使用的概念，计算机内存中保存的始终是 **位模式**。**对于相同的位模式，不同的类型表现形式不同**

# 线性数据结构

## 线性表

**线性表**，顾名思义，就是 **具有像线一样的性质的序列**。数学符号的记法如下：线性表记为 $(a_1,a_2,\cdots, a_n)$，则表中 $a_{i-1}$ 领先于 $a_i$，称 $a_{i-1}$ 是 $a_i$ 的 **直接前驱元素**，当然，$a_i$ 领先于 $a_{i+1}$ ，称 $a_{i+1}$ 是 $_{i}$ 的 **直接后继元素**

![[Drawing 2024-06-24 10.54.09.excalidraw|900]]

线性表的元素个数 $n(n \ge 0)$ 称为 **线性表的长度**，当 $n=0$ 是称为 **空表**。在 **非空表中的每个元素都有一个确定的位置**

例如，$1$ 是第一个数据元素，$n$ 是最后一个数据元素，$i$ 是第 $i$ 个数据元素，称 $i$ 为数据元素 $i$ 在线性表中的 **位序**

一年里的星座列表是不是线性表？毫无疑问是的

![[Drawing 2024-06-24 11.07.15.excalidraw|900]]

班级同学的花名册就是线性表。首先，它是有限的序列，类型相同。其次，每个元素除学生学号外还可以有其他的信息。**比较复杂的线性表中，一个 _数据元素_ 可以由若干 _数据项_ 组成**

既然是一个 **表结构**，首先需要存储数据，**_创建表_**（或初始化表）是首先需要执行的操作；需要向表中 **_插入_** 数据，当数据不需要的时候 **_删除_**，这两个基本操作是必不可少的。当表中数据到达一定量的时候，发现在表中 **_搜索_** 数据变得麻烦了，可能需要对表中数据进行 **_排序_**，搜索和排序必须要知道表的数据长度；数据会时常发生变化，**_修改_** 数据是不可避免的被需要。当表不被需要时，**_销毁表_** 是必不可少的操作

### 顺序表

线性表 $(a_1, a_2, \cdots, a_n)$ 的顺序存储示意图如下

![[assets/images/Pasted image 20240610220823.png|900]]

顺序存储就是使用一段 **连续的存储单元** 依次存储线性表的数据元素。只需要知道内存空间的起始位置 `ptr`，内存空间存储元素的容量 `MAXSIZE` 和当前内存空间中已存储的元素格式 `Length`，就可以定位每一个元素

![[Pasted image 20240530125021.png|900]]

存储器中每个存储单元都有自己的编号，称为地址。假设线性元素占用的 $c$ 个存储单元，那么线性表中第 $i$ 个元素的地址可以通过如下关系得到

$$
\text{LOC}(a_i) = \text{LOC}(a_1) + (i-1) * c
$$

![[assets/images/Pasted image 20240610221327.png|900]]

> [!summary] 总结
> 总结：顺序表中的元素可以 **随机访问**，访问效率非常高，其时间复杂度为 $O(1)$

#### 插入

插入同样出现两种情况：**在顺序表 _末尾插入_** 和 **在顺序表 _中间插入_**

插入数据一定为遇到一个问题！**_预先申请的内存空间不够使用_**，遇到这种情况时，通常会 **_触发顺序表扩容策略_**：会重新分配内存，并将元素从原来的位置复制到新开辟的内存空间中

如果没有触发顺序表的扩容策略，那么在顺序表末尾追加元素的效率就非常高了，其时间复杂度为 $O(1)$

但是，在顺序表中间插入，就会将 **插入位置及之后的元素整体向后移动一个位置**，插入效率就变得非常低了，其时间复杂度为 $O(N)$，$N$ 表示顺序表的规模(即元素的个数)

插入操作的示意图为：

![[assets/images/Pasted image 20240610223606.png|900]]

#### 删除

当我们要从顺序表中 **删除元素** 时，情况就变得复杂起来

如果删除元素在 **顺序表的末尾**，可以简单的修改顺序表中记录的元素个数。这样删除的效率也非常高，时间复杂度为 $O(1)$

大多数情况。删除元素通常会在 **顺序表中的中间**，甚至是 **开头**。为了保证满足**顺序表中的元素连续存放**，就需要 **向前移动元素**。这样删除的效率就变得非常低了，时间复杂度为 $O(N)$，$N$ 表示顺序表的规模(即元素的个数)

![[assets/images/Pasted image 20240610222630.png|900]]

### 链表

在顺序表中，插入和删除都需要找到插入位置和删除的位置，这是无法避免的开销。插入之前需要移动元素，将插入位置空出来；删除之后需要移动元素填充被移出的元素空闲位置。

为了避免插入之前和删除之后移动元素带来的开销，我们允许表的数据元素可以 **不连续存储**，这样就避免插入之前和删除之后带来的元素移动性能损耗。下图是链表的描述

![[Drawing 2024-06-24 15.04.42.excalidraw|900]]

由于数据元素的存储不连续，因此，为了表示每个数据元素 $a_i$ 与其直接后继数据元素 $a_{i+1}$ 之间的逻辑关系。对于数据  $a_i$ 来说，除了存储其 **本身的信息** 外，还需要存储一个 **表示其直接后继的信息**，即 **直接后继的存储位置**
- 把存储数据元素信息的域称为 **数据域**
- 存储直接后继位置的域称为 **指针域**

$n$ 个结点链接成一个**链表**，即线性表 $(a_1,a_2,\cdots,a_n)$ 的链式存储结构

![[Drawing 2024-07-22 00.18.23.excalidraw|900]]

对于链表而言，我们需要知道 **第一个元素所在的位置**。只需要记录第一个元素的指针，整个链表的存取就必须从头指针开始，之后的每一个节点就是上一个的的后继指针指向的位置。链表的 **最后一个结点指针为空**，通常用 `NULL` 表示

![[Drawing 2024-07-22 00.25.45.excalidraw|900]]

由于链表将逻辑关系存储为了结点指向其后继元素的指针。因此，我们将链表显示表示为

![[Drawing 2024-07-22 00.31.07.excalidraw|900]]

#### 插入

假设存储元素 `e` 的结点为 `s`，插入后，结点 `s` 的前驱节点为 `p`，后继结点为 `p->nex`，如图

![[Drawing 2024-06-24 15.15.15.excalidraw|900]]

#### 删除

删除操作只需要将 **前一个结点的指针域指向后一个结点即可**

![[Drawing 2024-06-24 15.20.55.excalidraw|900]]

### 其他线性数据结构
#### 栈
栈也是一个线性表，只是 **栈的插入和删除操作被限制在同一端**
- 插入操作被称为 **入栈**
- 删除操作被称为 **出栈**

下图描述了栈逻辑结构和插入与删除操作

![[assets/images/Pasted image 20240611153933.png|900]]

> [!tip] 栈的插入和删除操作限制在同一端，因此 **先入栈的数据最后弹出**(Lirst In Fast Out, **LIFO**)

#### 队列

队列也是线性表，然而，队列的 **插入在一端进行** 而 **删除则在另一端进行**
- 插入操作称为 **入队**
- 删除操作称为 **出队**

下图描述了队列的逻辑结构和插入与删除操作

![[assets/images/Pasted image 20240611154146.png|900]]

> [!tip] 队列的插入和删除限制在不同端，因此 **先入队的数据一定先出队**(First In First Out, **FIFO**)

## 数组

Go 数组是一个线性表，由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。和 C 语言中的数组类似。唯一不同的就是 Go 数组是 **值类型**

因为数组的长度是固定的，因此在 Go 语言中很少直接使用数组。和数组对应的类型是 切片，它是可以增长和收缩动态序列，`slice` 功能也更灵活，但是要理解 `slice` 工作原理的话需要先理解数组

声明数组的语法和普通变量是一样的。只需要注意数组的类型标识。Go 的数组类型标识为 `[N]Type`，其中 `N` 必须是一个常量表达式。这意味着，**数组的长度是不变的**

```go
var Array [N]Type = [N]Type{value1, value2, value3, ....}
```

和普通变量一样 类型信息 `[N]Type` 和 字面量 `[N]Type{....}` 可以任意省略一项

+ 如果省略字面量，则数组中的所有元素被初始化为 `Type` 的零值
+ 如果省略类型，类型由字面量推断。字面量中可以指定索引初始化

```go
var b = [4]int{1: 2, 3: 2}
fmt.Printf("%#v\n", b) // [4]int{0, 2, 0, 2}
```

> [!important] 在给定字面量时，数组的长度可以由编译器自动推断。

```go
var c = [...]int{10, 2, 30, 9: 20} // 长度推断为 10
fmt.Printf("%#v\n", c)             // [10]int{10, 2, 30, 0, 0, 0, 0, 0, 0, 20}
```

**数组的每个元素可以通过索引下标来访问**，索引下标的范围是从 `0` 开始到数组长度减 `1` 的位置。内置的 `len` 函数将返回数组中元素的个数

```go
var a [3]int             // 3 个整数的数组
fmt.Println(a[0])        // 数组的第一个元素
fmt.Println(a[len(a)-1]) // 数组的最后一个元素
a[2] = 10
a[3] = 10 // invalid argument: index 3 out of bounds。编译期错误
```

> [!warning] 注意：Go 数组 **不支持负索引**。**索引不能越界**，越界的访问将导致编译失败


遍历数组元素有两种方法：使用索引和 `range` 关键字

```go
var a [3]int             // 3 个整数的数组

// 使用索引遍历数组
for i := 0; i < len(a); i++ {
	fmt.Println(i, a[i])
}

// 使用 range 关键字
for i, v := range a {
	// i 索引
	// v 是元素
	fmt.Println(i, v)
}
```

Go 语言的多维数组类型 `[N][M]Type`。它本质上还是一个一维数组，长度为 `N` 元素类型为 `[M]Type` 的一维数组

> [!important] 二维数组按行主序存储

```go
// 二维数组
var d [3][4]int = [3][4]int{{1, 2, 3, 4}, {2, 3, 4, 5}, {4, 5, 6, 7}}
fmt.Printf("%#v\n", d) // [3][4]int{[4]int{1, 2, 3, 4}, [4]int{2, 3, 4, 5}, [4]int{4, 5, 6, 7}}
```

![[Drawing 2024-06-24 19.37.21.excalidraw|900]]


### 数组的内存模型

```go
var a [3]int

for i := 0; i < len(a); i++ {
	fmt.Println(i, a[i], &a[i])
}
fmt.Printf("%p %p, %v\n", &a, &a[0], a)
a[0] = 100

fmt.Printf("%p %p, %v\n", &a, &a[0], a)
```

上述代码段的一次允许结果为

```
0 0 0xc0000180c0
1 0 0xc0000180c8
2 0 0xc0000180d0
0xc0000180c0 0xc0000180c0, [0 0 0]
0xc0000180c0 0xc0000180c0, [100 0 0]
```

+ 数组必须在编译时就确定大小，之后不能改变大小
+ 数组首地址就是数组地址
+ 所有元素一个接一个顺序存储在内存中
+ 元素的值可以改变，但是元素地址不变

上面每个元素间隔 $8$ 个字节，正好 $64$ 位，符合 `int` 类型定义

如果数据元素是字符串类型呢？
```go
var b = [3]string{"abc", "b", "xyz"}
for i := 0; i < len(b); i++ {
	fmt.Println(i, b[i], &b[i])
}
fmt.Printf("%p %p, %v\n", &b, &b[0], b)
b[0] = "oooooo"
fmt.Printf("%p %p, %v\n", &b, &b[0], b)
```

上面这段代码执行的结果为

```
0 abc 0xc000094090
1 b 0xc0000940a0
2 xyz 0xc0000940b0
0xc000094090 0xc000094090, [abc b xyz]
0xc000094090 0xc000094090, [oooooo b xyz]
```

+ 数组首地址就是数组地址
+ 所有元素顺序存储在内存中
+ 元素的值可以改变，但是元素地址不变

每个元素间隔 $16$ 个字节，为什么？`"abc"` 是几个字节？这说明什么？

### 值类型

Go 的数组是 **值类型**，**赋值和传参都会创建一个全新的副本**

```go
package main

import "fmt"

func main() {

	var a [3]int
	var b = a // 将会复制一份
	
	fmt.Printf("&a=%p &b=%p\n", &a, &b)
	b[1] = 100
	fmt.Printf("a=%v b=%v\n", a, b)
	
	fmt.Println("----------------------------")
	c := showAddr(a)

	fmt.Printf("从函数返回: &c=%p\n", &c)
	fmt.Printf("从函数返回: c=%v\n", c)
}

func showAddr(arr [3]int) [3]int {
	fmt.Printf("函数内部: &arr = %p\n", &arr)
	arr[0] = 200
	fmt.Printf("函数内部: arr = %v\n", arr)
	return arr
}
```

上述代码的执行结果为

```
&a=0xc0000180c0 &b=0xc0000180d8
a=[0 0 0] b=[0 100 0]
----------------------------
函数内部: &arr = 0xc000018138
函数内部: arr = [200 0 0]
从函数返回: &c=0xc000018120
从函数返回: c=[200 0 0] a=[0 0 0]
```

> [!important] Go 语言在 **赋值** **传参**和 **从函数返回** 时都对数组进行了 **值拷贝**，都生成了一份副本

## 切片

**切片** 代表 **变长的序列**，序列中每个元素都有相同的类型。一个 `slice` 类型一般写作 `[]Type`，其中 `Type` 代表 `slice` 中元素的类型；`slice` 的语法和数组很像，只是没有固定长度而已

数组和 `slice` 之间有着紧密的联系。一个 `slice` 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且 `slice` 的底层确实引用一个数组对象。一个 `slice` 由三个部分构成：**_指针_** **_长度_** 和 **_容量_**
+ 指针指向第一个 `slice` 元素对应的底层数组元素的地址，要注意的是 `slice` 的第一个元素并不一定就是数组的第一个元素
+ 长度对应 `slice` 中元素的数目；长度不能超过容量
+ 容量一般是从 `slice` 的开始位置到底层数据的结尾位置

内置的 `len` 和 `cap` 函数分别返回 `slice` 的长度和容量

### 定义切片

切片的类型为 `[]Type`，为了声明一个切片，其语法如下

```go
var Slice []Type = []Type{....}  // 定义切片
```

和数组一样，可以省略 `[]Type` 和 `[]Type{...}` 中的一个
+ 如果省略 `[]Type`，类型从初始化表达式中推断，同时会开辟初始元素个数的底层数组。长度和容量相等
+ 如果省略 `[]Type{....}`，内存中不会开辟底层数组。长度和容量都等于 $0$

> [!important] 省略了 `[]Type{....}` 仅仅只是创建了一个切片变量，还没有底层数组被这个切片管理

```go
package main  
  
import "fmt"  
  
/* 创建切片的方法 */  
func main() {  
    var slice []int       // 仅仅只是声明的一个切片，它还没有管理任何底层数组  
    fmt.Println(slice[0]) // panic: runtime error: index out of range [0] with length 0  
    fmt.Println(slice == nil)  // true
}
```

切片是引用类型，**默认值为 `nil`**。因此，声明切片就必须初始化之后才能被使用

创建切片最常用的方式是使用 `make` 函数。使用 **切片表达式** 和 `var` 方式都有自己的局限性
+ 切片表达式，需要一个底层数组或已有切片
+ `var` 方式通常只能用于小批量的初始元素的情况

为了能够创建任意长度和容量的切片，Go 提供了 `make()` 函数。用于创建切片时，需要提供三个参数

```go
make([]Type, len, cap)
```

- `[]Type`：切片的类型
- `len`：切片的长度
- `cap` ：切片的容量

```go
package main

import "fmt"

func main() {
	a := make([]int, 2, 10) // 长度为 2 容量为 10
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10

	a = make([]int, 10) // 长度和容量均为 10
	fmt.Println(a)
	fmt.Println(len(a))
	fmt.Println(cap(a))
}
```

### 内存模型
![[Pasted image 20240624215819.png|900]]

切片本质是对底层数组一个连续 **片段** 的引用。此片段可以是整个底层数组，也可以是由起始和终止索引标识的一些项的子集。

在 `${GOROOT}/src/runtime/slice.go` 中切片的定义如下

```go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

> [!important] 切片仅仅只是一个结构体，只是这个结构体管理了一个底层数组
> + 先知道：**结构体** 是值类型

```go
var s []int = []int{1, 3, 5, 7}
fmt.Printf("%v, %p, %p\n", s, &s, &s[0]) // [1 3 5 7], 0xc00012e030, 0xc000134020
```

`&s` 是切片结构体的地址，`&s[0]` 是底层数组的地址

### 切片比较

和数组不同的是，**`slice` 之间不能比较**，因此我们不能使用 `==` 操作符来判断两个 `slice` 是否含有全部相等元素。不过标准库提供了高度优化的 `bytes.Equal` 函数来判断两个字节型 `slice` 是否相等（`[]byte`），但是对于其他类型的 `slice`，我们必须自己展开每个元素进行比较：例如，下面的 `equal` 函数给出了判断两个 `string` 切片元素是否相等的逻辑

```go
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

### 向切片中添加元素

内置的 `append` 函数用于向 `slice` 追加元素。可以 **一次添加一个元素**，可以 **添加多个元素**，也可以 **添加另一个切片中的元素**。

```go
Slice = append(Slice, element1, element2, ...)
```

调用 `append` 时，需要指定元素添加在那个切片中。如果切片的底层输入可以容纳新添加的元素，`append` 只会导致切片的长度变化

由于切片本质就是一个结构体，参数传递时执行值拷贝，被调函数内部的修改无法影响到调用函数中变量的值，因此 `append` 需要返回这个切片

```go
package main

import "fmt"

func main() {
	s1 := make([]int, 3, 5)
	fmt.Printf("s1: %p, %p, len=%d, cap=%d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	s2 := append(s1, 1, 2) // append 会返回一个新的切片
	fmt.Printf("s2: %p, %p, len=%d, cap=%d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
}
```

这段代码的运行结果为

```
s1: 0xc000010018, 0xc00001c0c0, len=3, cap=5, [0 0 0]
---------------------------------------------------------------------
s1: 0xc000010018, 0xc00001c0c0, len=3, cap=5, [0 0 0]
s2: 0xc000116000, 0xc00001c0c0, len=5, cap=5, [0 0 0 1 2]
```

内存模型图为

![[Drawing 2024-06-24 22.28.16.excalidraw|900]]

> 目前没有超过容量，底层 **共用同一个数组**，但是，对底层数组 **使用的片段不一样**


继续向 `s1` 中添加元素

```go
// 继续向 s1 中添加元素 -1
s3 := append(s1, -1)
fmt.Println("---------------------------------------------------------------------")
fmt.Printf("s1: %p, %p, len=%d, cap=%d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2: %p, %p, len=%d, cap=%d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3: %p, %p, len=%d, cap=%d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
```

这段代码的输出结果为

```
---------------------------------------------------------------------
s1: 0xc000010018, 0xc00001c0c0, len=3, cap=5, [0 0 0]
s2: 0xc000010048, 0xc00001c0c0, len=5, cap=5, [0 0 0 -1 2]
s3: 0xc000010090, 0xc00001c0c0, len=4, cap=5, [0 0 0 -1]
```

内存模型图为

![[Drawing 2024-06-24 22.37.47.excalidraw|900]]

> 目前三个切片底层用同一个数组，只不过长度不一样


如果切片的底层输入无法容纳新添加的元素，就会触发切片的 **扩容策略**，现在，向 `s3` 中添加元素 `3, 4, 5`

```go
// 向 s3 中添加元素 3, 4, 5
s4 := append(s3, 3, 4, 5)
fmt.Println("---------------------------------------------------------------------")
fmt.Printf("s1: %p, %p, len=%d, cap=%d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2: %p, %p, len=%d, cap=%d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3: %p, %p, len=%d, cap=%d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
fmt.Printf("s4: %p, %p, len=%d, cap=%d, %v\n", &s4, &s4[0], len(s4), cap(s4), s4)
```

这段代码的执行结果为
```
---------------------------------------------------------------------
s1: 0xc00012e000, 0xc000130000, len=3, cap=5, [0 0 0]
s2: 0xc00012e030, 0xc000130000, len=5, cap=5, [0 0 0 -1 2]
s3: 0xc00012e078, 0xc000130000, len=4, cap=5, [0 0 0 -1]
s4: 0xc00012e0d8, 0xc000144000, len=7, cap=10, [0 0 0 -1 3 4 5]
```

内存模型下图

![[Drawing 2024-06-24 22.43.34.excalidraw|1000]]

> 底层数组变了，容量也增加了

在 `s4` 的基础上，继续添加元素 `6, 7, 8, 9` 

```go
s5 := append(s4, 6, 7, 8, 9)
fmt.Println("---------------------------------------------------------------------")
fmt.Printf("s1: %p, %p, len=%d, cap=%d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
fmt.Printf("s2: %p, %p, len=%d, cap=%d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
fmt.Printf("s3: %p, %p, len=%d, cap=%d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
fmt.Printf("s4: %p, %p, len=%d, cap=%d, %v\n", &s4, &s4[0], len(s4), cap(s4), s4)
fmt.Printf("s5: %p, %p, len=%d, cap=%d, %v\n", &s5, &s5[0], len(s5), cap(s5), s5)
```

这段代码的执行结果为

```
---------------------------------------------------------------------
s1: 0xc000010018, 0xc00001c0c0, len=3, cap=5, [0 0 0]
s2: 0xc000010048, 0xc00001c0c0, len=5, cap=5, [0 0 0 -1 2]
s3: 0xc000010090, 0xc00001c0c0, len=4, cap=5, [0 0 0 -1]
s4: 0xc0000100f0, 0xc0000ae000, len=7, cap=10, [0 0 0 -1 3 4 5]
s5: 0xc000010168, 0xc0000260a0, len=11, cap=20, [0 0 0 -1 3 4 5 6 7 8 9]
```

内存模型图为

![[Drawing 2024-06-24 22.50.01.excalidraw|2000]]

+ `append` 一定返回一个新的切片
+ `append` 可以增加若干元素
	+ 如果增加元素时，当前 `长度 + 新增个数 <= cap` 则不扩容
		+ 原切片使用原来的底层数组，返回的新切片也使用这个底层数组
		+ 返回的新切片有新的长度
		+ 原切片长度不变
	+ 如果增加元素时，当前 `长度 + 新增个数 > cap` 则需要扩容
		+ 生成新的底层数组，新生成的切片使用该新数组，将旧元素复制到新数组，其后追加新元素
		+ 原切片底层数组、长度、容量不变

> [!important] 使用 `append` 函数时，通过让其返回的切片直接覆盖原来切片

#### 扩容策略

分析上面的输出，我们模拟下一 `append` 函数的执行过程
+ 需要返回一个新切片
+ 根据添加元素个数判断是否需要扩容
+ 目前来看，扩容只是简单的容量翻倍

```go
func appendInt(x []int, y ...int) []int {

	// 新切片：返回的切片
	var z []int

	zlen := len(x) + len(y) // 新切片的长度

	// 判断是否还有容量可以存放元素
	if zlen <= cap(x) {
		// 我们还有成长的空间。扩展切片
		z = x[:zlen]
	} else {
		// 需要扩容
		// 重新分配空间
		zcap := zlen
		if zcap < 2*cap(x) {
			zcap = 2 * cap(x)
		}

		z = make([]int, zlen, zcap)

		// 将原来的元素复制到新的空间
		copy(z, x)
	}

	// 添加元素
	for i, v := range y {
		z[len(x)+i] = v
	}

	return z
}
```

> [!tip] 内置函数 `copy(dst, src)` 可以方便的把 `src` 切片中的元素复制到 `dst` 切片中 

测试 `appendInt` 

```go
var a = make([]int, 3, 5)
fmt.Printf("a: %p, %p, len=%d, cap=%d, %v\n", &a, &a[0], len(a), cap(a), a)

b := appendInt(a, 1, 2)
fmt.Println("---------------------------------------------------------------------")
fmt.Printf("a: %p, %p, len=%d, cap=%d, %v\n", &a, &a[0], len(a), cap(a), a)
fmt.Printf("b: %p, %p, len=%d, cap=%d, %v\n", &b, &b[0], len(b), cap(b), b)

c := appendInt(b, 2, 3)
fmt.Println("---------------------------------------------------------------------")
fmt.Printf("a: %p, %p, len=%d, cap=%d, %v\n", &a, &a[0], len(a), cap(a), a)
fmt.Printf("b: %p, %p, len=%d, cap=%d, %v\n", &b, &b[0], len(b), cap(b), b)
fmt.Printf("c: %p, %p, len=%d, cap=%d, %v\n", &c, &c[0], len(c), cap(c), c)
```

输出结果为

```
a: 0xc000010018, 0xc00001c0c0, len=3, cap=5, [0 0 0]
---------------------------------------------------------------------
a: 0xc000010018, 0xc00001c0c0, len=3, cap=5, [0 0 0]
b: 0xc000100000, 0xc00001c0c0, len=5, cap=5, [0 0 0 1 2]
---------------------------------------------------------------------
a: 0xc000010018, 0xc00001c0c0, len=3, cap=5, [0 0 0]
b: 0xc000100000, 0xc00001c0c0, len=5, cap=5, [0 0 0 1 2]
c: 0xc000100048, 0xc000106000, len=7, cap=10, [0 0 0 1 2 2 3]
```

在 `$GOROOT/src/runtime/slice.go` 源码中，与扩容相关代码如下：

```go
// nextslicecap computes the next appropriate slice length.
func nextslicecap(newLen, oldCap int) int {
	newcap := oldCap
	doublecap := newcap + newcap  // 首先将容量翻倍
	// 如果申请的空间大于原来空间的两倍，则直接返回申请的容量
	if newLen > doublecap {
		return newLen
	}
	
	// 设定一个阈值
	const threshold = 256
	// 申请的空间小于原来空间的两倍 并且 原始容量小于阈值，将容量翻倍
	if oldCap < threshold {
		return doublecap
	}
	// 申请的空间小于原来空间的两倍 并且 原始容量大于或等于阈值
	for {
		// 从小切片增长 2 倍过渡到大切片增长 1.25 倍。这个公式可以在两者之间实现平滑过渡
		newcap += (newcap + 3*threshold) >> 2  // newcap = newcap + newcap / 4 + 3 * 256 / 4 => newcap = 1.25 * newcap + 192

		// 我们需要检查 `newcap >= newLen` 和 `newcap` 是否溢出。
		// newLen 保证大于零，因此当 newcap 溢出时，`uint(newcap) > uint(newLen)`。 
		// 这样就可以通过相同的比较对两者进行检查。
		if uint(newcap) >= uint(newLen) {
			break
		}
	}

	// 当 newcap 计算溢出时，将 newcap 设置为请求的上限。
	if newcap <= 0 {
		return newLen
	}
	return newcap
}
```

(新版本1.18+) 阈值变成了 $256$，当扩容后的 `cap<256` 时，扩容翻倍，容量变成之前的 `2` 倍;当 `cap>=256` 时，`newcap +=(newcap + 3*threshold)/4` 计算后就是 `newcap = newcap + newcap/4 + 192`，即 `1.25` 倍后再加 `192`

（老版本）实际上，当扩容后的 `cap<1024` 时，扩容翻倍，容量变成之前的 `2` 倍；当 `cap>=1024` 时，变成之前的 `1.25` 倍

> [!warning] 扩容是耗时操作：因为需要将元素拷贝到新的内存空间
> 
> **扩容是 _创建新的内部数组_**，把原内存数据 **_拷贝到新内存空间_**，然后在新内存空间上执行元素追加操作
> 
> **切片频繁扩容成本非常高，所以尽量早估算出使用的大小，一次性给够**，建议使用 `make`。常用 `make([]int, 0, 100)` 。

思考一下：如果 `s1 := make([]int, 3, 100)` ，然后对 `s1` 进行 `append` 元素，会怎么样？
+ 添加元素个数少于 `97` 时，不会触发扩容策略
+ 添加元素个数大于 `97` 时，触发扩容策略

### 引用类型

```go
package main

import "fmt"

func main() {

	s1 := []int{10, 20, 30} // 创建一个切片类型的变量
	// 切片地址(&s1)  底层数组地址(&s1[0])  切片管理元素的个数即长度(len(s1))  底层数组的长度即容量(cap(s1))
	fmt.Printf("s1 %p, %p, %d, %d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	s2 := s1  // 使用 s1 创新创建了一个切片，共用同一个底层数组
	fmt.Printf("s2 %p, %p, %d, %d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
	fmt.Println("~~~~~~~~~~~~~~~~~~~~~~~~~~~")
	
	s3 := showAddr(s1)
	fmt.Printf("s1 %p, %p, %d, %d, %v\n", &s1, &s1[0], len(s1), cap(s1), s1)
	fmt.Printf("s2 %p, %p, %d, %d, %v\n", &s2, &s2[0], len(s2), cap(s2), s2)
	fmt.Printf("s3 %p, %p, %d, %d, %v\n", &s3, &s3[0], len(s3), cap(s3), s3)
}

func showAddr(s []int) []int {
	fmt.Printf("调用 append 之前: %p, %p, %d, %d, %v\n", &s, &s[0], len(s), cap(s), s)
	// 修改一个元素
	if len(s) > 0 {
		s[0] = 123
	}
	fmt.Printf("调用 append 之前，修改s[0] 之后: %p, %p, %d, %d, %v\n", &s, &s[0], len(s), cap(s), s)

	s = append(s, 100, 200) // 覆盖s，请问s1会怎么样
	fmt.Printf("调用 append 之后: %p, %p, %d, %d, %v\n", &s, &s[0], len(s), cap(s), s)
	return s
}
```

`s1 := []int{10, 20, 30}` 将创建一个切片，并管理一个长度为 $3$ 底层数组。执行 `s2 := s1` 将创建另一个切片，管理与 `s1` 相同的底层数组

![[Drawing 2024-06-25 00.35.56.excalidraw|900]]

调用 `showAddr(s1)` 时，会将 `s1` 中的内容拷贝到 `showAddr` 的形参 `s` 中。当执行 `s[0] = 123` 之后，导致所有的切片都能观察到底层数组的改变

![[Drawing 2024-06-25 00.41.19.excalidraw|900]]

当代码执行了 `s = append(s, 100, 200)` 之后。内存模型变成了

![[Drawing 2024-06-25 00.47.13.excalidraw|900]]

当 `showAddr(s1)` 返回后，内存模型变成了

![[Drawing 2024-06-25 00.49.36.excalidraw|900]]

根据上述分析，这段代码的执行结果为

```
s1 0xc000010018, 0xc0000180c0, 3, 3, [10 20 30]
s2 0xc000100000, 0xc0000180c0, 3, 3, [10 20 30]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
调用 append 之前: 0xc000100048, 0xc0000180c0, 3, 3, [10 20 30]
调用 append 之前，修改s[0] 之后: 0xc000100048, 0xc0000180c0, 3, 3, [123 20 30]
调用 append 之后: 0xc000100048, 0xc00010e000, 5, 6, [123 20 30 100 200]
s1 0xc000010018, 0xc0000180c0, 3, 3, [123 20 30]
s2 0xc000100000, 0xc0000180c0, 3, 3, [123 20 30]
s3 0xc000100030, 0xc00010e000, 5, 6, [123 20 30 100 200]
```

可以看出，切片其实这里还是 **值拷贝**，不过拷贝的是切片的标头值（Header）。**标头值内指针也被复制**，刚复制完大家指向同一个底层数组罢了。但是仅仅知道这些不够，因为一旦操作切片时扩容了，或另一个切片增加元素，那么就 **不能简单归结为“切片是引用类型，拷贝了地址”** 这样简单的话来解释了。要具体问题，具体分析。

> [!summary] 总结
> **切片仅仅只是一个结构体**，只是携带了 **底层数组的指针**、**当前管理的元素个数(长度)** 和 **底层数组的长度(容量)**。在 Go 中这样携带底层数据结构的指针的类型称为 **引用类型**
> + 不要混淆其他语言中的引用类型
> 

> [!important] Go 实参传递：**全是值传递**
> Go 语言中全都是函数 **实参传递** 全是 **值传递**，整型、数组这样的类型的值是完全复制，`slice`、`map`、`channel`、`interface`、`function` 这样的引用类型也是值拷贝，不过复制的是标头值
> 
> + 参考 [[godev/笔记/函数基础]]

> 参考视频
> [slice类型存什么？make和new？slice和数组？扩容规则？](https://www.bilibili.com/video/BV1CV411d7W8/)

### 切片表达式

**多个 `slice` 之间可以共享底层的数据，并且引用的数组部分区间可能重叠**。下面的代码声明了一个数组表示一年中每个月份名字的字符串数组

```go
months := [...]string{
	1:  "January",
	2:  "February",
	3:  "March",
	4:  "April",
	5:  "May",
	6:  "June",
	7:  "July",
	8:  "August",
	9:  "September",
	10: "October",
	11: "November",
	12: "December",
}
```

这样，一月份是 `months[1]`，十二月份是 `months[12]`。数组的第一个元素从索引0开始，但是月份一般是从 `1` 开始的，因此我们声明数组时直接跳过第 `0` 个元素，第 `0` 个元素会被自动初始化为空字符串

![[Drawing 2024-06-24 21.02.57.excalidraw|150]]


`slice` 的切片操作 `s[i:j]`，其中 `0 <= i <= j <= cap(s)`，用于创建一个新的 `slice`，引用 `s` 的从第 `i` 个元素开始到第 `j-1` 个元素的子序列。新的 `slice` 将只有 `j-i` 个元素
+ 如果`i` 位置的索引被省略的话将使用 `0` 代替
+ 如果 `j` 位置的索引被省略的话将使用 `len(s)` 代替

因此，`months[1:13]` 切片操作将引用全部有效的月份，和 `months[1:]` 操作等价；`months[:]` 切片操作则是引用整个数组。让我们分别定义表示第二季度和北方夏天月份的 `slice`，它们有重叠部分

```go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2, len(Q2), cap(Q2))             // [April May June] 3 9
fmt.Println(summer, len(summer), cap(summer)) // [June July August] 3 7
```

![[Drawing 2024-06-24 21.13.16.excalidraw|900]]

两个 `slice` 都包含了六月份，下面的代码是一个包含相同月份的测试（性能较低）

```go
for _, s := range summer {
    for _, q := range Q2 {
        if s == q {
            fmt.Printf("%s appears in both\n", s)
        }
    }
}
```

如果切片操作超出 `cap(s)` 的上限将导致一个 `panic` 异常，但是超出 `len(s)` 则是意味着扩展了 `slice`，因为新 `slice` 的长度会变大

```go
fmt.Println(summer[:20]) // panic: out of range
endlessSummer := summer[:5] // extend a slice (within capacity)
fmt.Println(endlessSummer)  // "[June July August September October]"
```

因为 `slice` 值包含指向第一个 `slice` 元素的指针，因此向函数传递 `slice` 将允许在函数内部修改底层数组的元素。换句话说，复制一个 `slice` 只是对底层的数组创建了一个新的 `slice` 别名。下面的 `reverse` 函数在原内存空间将 `[]int` 类型的 `slice` 反转，而且它可以用于任意长度的 `slice`

```go
// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

> [!summary] **多个切片直接可以  _共用_ 底层数组，引用的底层数组 _部分区间可能重叠_**
