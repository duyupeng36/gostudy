---
sticker: lucide//home
---
# Go Developer(Go 开发者)

## 描述

记录了成为 Go Developer 的学习历程，包括学习资料、学习笔记、项目实战等

## 笔记

### 第一章：计算机基础

+ [[计算机模型]]
	+ 图灵模型：程序+数据处理器。数据存储在内存，程序则不是
	+ 冯洛伊曼模型：程序和数据都存储在计算机内存中。
		+ 程序和数据均使用位模式表示

+ [[数字系统]]
	+ 十进制、二进制、八进制、十六进制
	+ 十进制 => 其他进制
		+ 整数部分（称为 _源_）：连续除法。_源_ 除以进制 _基数_；余数作为目标进制数的当前最右端，商作为新的源
		+ 小数部分（称为 _源_）：连续乘法。_源_ 乘以进制 _基数_；积整数部分作为目标进制数的当前最左端，积的小数部分作为新的源
	+ 其他进制 => 十进制
		+ 各个位上的数与位权的积的和
	+ 八进制 <=> 二进制 <=> 十六进制
		+ 八进制 <=> 二进制：一个八进制数等于三位二进制数
		+ 二进制 <=> 十六进制：一个十六进制数等于四位二进制数

+ [[存储数据]]
	+ 存储整数：无符号编码；符号+绝对值；二进制补码
		+ 无符号编码：位模式的所有位均表示数值，第 $i$ 位的位权为 $2^{i}$
		+ 符号+绝对值：位模式的最高位表示符号($0$ 表示 `+`，$1$ 表示 `-`)，余下的位表示数值
		+ 二进制补码：与 符号+绝对值表示法类似，唯一不同就是最高位也表示数值，权重为 $-2^{n-1}$ （$n$ 表示位模式的长度）
	+ 存储小数：IEEE 754 标准浮点数
		+ 单精度浮点数：使用 $32$ 位位模式表示
			+ 符号位($1$ 位)：表示正负
			+ 指数($8$ 位)：表示小数点移动位数，使用余 $127$ 码表示
			+ 尾数($23$位)：控制表示浮点数的精度
		+ 双精度浮点数：使用 $64$ 位位模式表示
			+ 符号位($1$ 位)：表示正负
			+ 指数($11$ 位)：表示小数点移动位数，使用余 $1023$ 码表示
			+ 尾数($52$ 位)：控制表示浮点数的精度
	+ 存储文本：字符编码（ASCII、Unicode、UTF-8）

+ [[数据运算]]
	+ 逻辑运算
		+ `and` 位与
		+ `or` 位或
		+ `xor` 位异或
		+ `not` 位取反
	+ 移位运算
		+ 逻辑移位：无论做移动还是右移动，空出的位均补零
		+ 算术移位：左移动在空出位补零；右移动在空出位补符号位的值
	+ 算术运算
		+ 补码求和

+ [[计算机组成原理]]
	+ 中央处理单元
		+ ALU：执行算术运算和逻辑运算
		+ 控制器（包括两个专用寄存器：`PC` 和 `IR`）
			+ `PC` 指向下一条指令的地址
			+ `IR` 当前正在执行的指令
		+ 数据寄存器
	+ 主存储器：存储单元的集合
		+ 每个存储单元都有唯一的标识，称为地址
		+ 数据以称为 **字** 的位组的形式在内存中 **传入** 和 **传出**
			+ 字可以是 $8$ 位、$16$ 位、$32$ 位、 $64$位
		+ 在存储器中存取每个字都需要相应的 **标识符**
			+ 程序员使用名字来区分字
			+ 在硬件层次上，**每个字都是通过地址来标识的**
		+ 所有在存储器中 **标识独立的地址单元** 的总数称为 **地址空间**
		+ RAM(随机存取) 和 ROM(只读存储器)
	+ 输入/输出(I/O)子系统
		+ 非存储设备
		+ 存储设备

---

|         字符         |    位模式     | 十进制  |  十六进制   |
| :----------------: | :--------: | :--: | :-----: |
| `NULL` 字符 (`'\0'`) | `000 0000` | `0`  | `0x00 ` |
| `SPACE` 字符 (`' '`) | `010 0000` | `32` | `0x20 ` |
|  `HT` 字符 (`'\t'`)  | `000 1001` | `9`  | `0x09 ` |
|  `CR` 字符 (`'\r'`)  | `000 1101` | `13` | `0x0d ` |
|  `LF` 字符 (`'\n'`)  | `000 1010` | `10` | `0x0a ` |
|  `VT` 字符 (`'\v'`)  | `000 1011` | `11` | `0x0b ` |
|  `FF` 字符 (`'\f'`)  | `000 1100` | `12` | `0x0c ` |
|      字符 `'0'`      | `011 0000` | `48` | `0x30 ` |
|      字符 `'1'`      | `011 0001` | `49` | `0x31 ` |
|      字符 `'A'`      | `100 0001` | `65` | `0x41 ` |
|      字符 `'a'`      | `110 0001` | `97` | `0x61`  |

---

### 第二章：语法基础

+ [[简介和Go环境搭建]]：GPROXY 必须配置，否则可能在安装第三方包的时候出错
	+ `go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,https://proxy.golang.org,direct`

+ [[基础语法]]：常量 变量 数据类型 `if` `switch` `for` 随机数 
	+ 常量：`const` 声明的标识符，Go 中只有基本类型的 **字面值** 才能初始化常量
		+ 没有常量数组
	+ 变量：使用 `var` 或者 `:=` 声明的标识符。Go 编译器可以自动从字面值推断变量的类型
	+ 数据类型
		+ 数值类型
			+ 整数：`int` `int8`  `int16` `int32` `int64`；`uint` `uint8` `uint16` `uint32` `uint64`
				+ `int` 和 `uint` 自动根据平台选择合适的尺寸
				+ 其余的是指定了尺寸
			+ 浮点数：采用 IEEE 754 标准
				+ 单精度浮点数 `float32`
				+ 双精度浮点数 `float64`
			+ 字符：这是一种整数类型
				+ `rune` 是 `int32` 的别名，存储 Unicode 代码
				+ `byte` 是 `uint8` 的别名，通常表示原始二进制数据，也可以用于存储 ASCII 码
			+ 指针 `uintptr` 是一种无符号的整数类型，该类型仅仅表示这个整数是指针，它引用对象
			+ 复数类型：`complex64` 和 `complex128`
		+ 布尔类型：`bool` 只有两个预定常量，分别是 `true` 和 `false`
			+ 是独立的一个类型，不要与其他语言混淆
		+ 字符串 `string`
			+ 一个字符串是一个 _不可改变_ 的 **字节序列**
			+ 文本字符串通常被解释为采用 `UTF-8` 编码的 `Unicode` 代码（`rune`）序列
	+ 运算符：
		+ `+ - * / %` 算术运算。注意 `%` 只能用于整数类型，`/` 用于整数时执行向下取整
		+ `& | ^(单目) ^`：位运算。`^` 做单目运算符时表示按位取反
		+ `>> <<`：移位运算。执行算术移位
		+ `== != > >= < <=`：比较运算。比较表达式的值是 `bool` 类型
		+ `&& || !`：逻辑运算。操作数必须是 `bool` 类型，一旦能确定逻辑表达式的值则立即返回(短路)
		+ `& *`：指针运算。`&` 取地址，`*` 解引用
	+ 控制流程
		+ `if condition {` 条件部分的表达式必须是 `bool` 类型
			+ 可以携带一个初始化语句 `if init; condition {`
			+ `if ... else`
			+ `if ... else if ... else`
		+ `switch initializer; expr {`
			+ `initializer` 可以有可无
			+ 如果 `expr` 没有，则 `case` 后面必须得条件语句
			+ `case` 语句可以使用多个标签
		+ `for initializer; condition; post {`
			+ `initializer; condition; post` 三者可以任意省略，提供了极大的灵活性
		+ `range` 关键字。安全的遍历容器
			+ Go 1.22  `range` 可以 `range n` 产生 `0 ~ n-1` 的等差序列
		+ `continue` 跳过当前或者指定标签循环
			+ `continue` 只能用于 `for` 循环
		+ `break` 提出当前或指定标签循环
			+ `break` 可用于 `switch` 和 `select`
		+ `goto` 无条件跳转。跳转到指定标签

### 第三章：内建数据结构

+ [[线性数据结构]]：数组 切片 
	+ 数组(`[n]Type`)：长度必须是常量，或者由编译器自动推断
		+ 长度一旦确定就不能修改了
		+ 数组是值类型，两个数组之间是可比较大小的
	+ 切片(`[]Type`)：一个结构体，包含了底层数组的 **指针**，**长度** 和 **容量**
		+ 指针：指向一个数组中的元素
		+ 长度：表示该切片管理的元素个数
		+ 容量：表示底层数组能存储的元素个数
		+ 切片是引用类型，两个切片之间不能进行比较。唯一能比较的是与 `nil` 进行 `==` 或 `!=` 的比较

+ [[字符串]]：`string`，也是一个结构体，包含了指向底层字节数组的 **指针**，和字节数组的 **长度** 
	+ `string` 包：提供了操作字符串的方法
		+ `Join` 拼接字符串
		+ `Trim` 删除两端空白字符
		+ `Fields` 在空白字符处切割
	+ `strcov` 包：提供了将字符串与数值之间转换的方法
		+ `Atoi` 字符串转为整数
		+ `ItoA` 整数转为字符串
		+ `ParseXXX` 解析字符串为指定类型的值
		+ `FormatXXX` 将指定类型值格式化为字符串

+ [[哈希表]]：`map` 类型 
	+ 将一种类型的值映射为另一种类型的值，即所谓了 `key-value` 键值对
	+ Go `map` 类型是一种 **哈希表**，采用 **拉链法** 解决 **哈希冲突**
	+ `map` 也是一种引用类型（一个结构体）。但是，**零值不可用的**，必须使用 `make` 或字面值开辟底层数据结构

---

### 第四章：函数

+ [[函数基础]] 
	+ 函数的声明 `func`
	+ 调用 `[返回值 :=] 函数名(实参列表)`
	+ 形参可以可无，也可以为可变长参数(被包装为切片)
	+ 返回值可有可无。如果有返回值，也可返回多个。返回值也可以命名，它属于局部作用域
	+ 由于 Go 包含垃圾回收，对象的生命周期完全由垃圾回收管理，所有 **_可以返回局部变量的指针_**

+ [[垃圾回收]] 
	+ **标记-清除**：需要 STW
	+ **_三色标记法_**：仍然需要依赖 STW 的
	+ **强/弱三色不变色**，解决 STW
		+ **_强_**：_不允许黑色对象引用白色对象_
		+ **_弱_**：_黑色对象可以引用白色对象，但是 **白色对象的上游必须存在灰色对象**_
	+ _**插入写屏障机制**_：当有一个对象引用其他对象时，**被引用对象标记为灰色**
		+ 满足 _强三色不变色_
		+ 只能在堆空间使用插入写屏障机制
		+ 缺点：栈空间需要开启 STW
	+ **_删除写屏障机制_**：被删除引用的对象自身为白色或灰色时，该对象标记为灰色
		+ 满足 _弱三色不变式_
		+ **白色对象始终会被灰色对象保护**
		+ 缺点：**一个对象的 _引用被删除后_，即使 _没有其他存活的对象引用它_，它 _仍然会活到下一轮_**
	+ **_混合写屏障机制_**：_栈_ 上的 _可达对象和新建对象_ 均标记为 _黑色_，_堆_ 上被删除引用的对象和新建对象被标记为 _灰色_
		+ 避免 STW

+ [[函数高级]] 
	+ 递归：自己调用自己（直接或间接）
	+ 高阶函数：需要函数作为参数或者返回函数的函数
	+ 匿名函数：顾名思义，没有名字的函数
	+ 函数嵌套：函数内部只可以定义匿名函数
	+ 闭包：延长了变量生命周期的函数
	+ defer：延迟调用，**实参在注册时求值**

+ [[指针]] 
	+ Go 的指针操作被限制，只支持 **取地址(`&`)** 和 **解引用(`*`)** 两种操作
	+ `new` 和 `make` 函数的区别
		+ `new` 通常为值类型开辟存储空间，并返回该类型的指针
		+ `make` 只用于 `slice` 和 `map` 和 `channel` 类型。返回这些类型的值。它会为  `slice` 和 `map` 和 `channel` 类型的底层数组结构分配内存空间

---

### 第五章：面向对象

+ [[结构体]] 
	+ 结构体(`struct`)：类似于其他面向对象语言中的 `class`，但是 Go 的结构体不是 `class`
	+ Go 结构体类型与 C 语言中的结构体类似。不同的是，Go 中可以为结构体定义成员函数(**方法**)
	+ 结构体是 **_值类型_**，如果所有的成员都是可比较的，那么这个结构体就是可比较
	+ 结构体指针
	+ 结构体支持 **匿名嵌入**，嵌入结构的字段可以直接访问
	+ 需要注意 **内存对齐** 要求
		+ 数据存储地址是对齐边界的整数倍
		+ 数据占用的字节数也是对齐边界的整数倍
	+ 对齐边界：类型尺寸和机器字长的最小值

+ [[方法]] 
	+ 属于某个 **_命名类型_** 的函数
	+ 值接收者和指针接收者
		+ 指针接受者可以修改对象的值
		+ 值接受者实际上就是对象的一份拷贝，对对象的修改是在函数的栈帧中，无法作用在原始对象上
	+ 匿名嵌入的结构体，不仅能获得嵌入结构体的字段，还能获得其方法
	+ Bit 数组的实现

+ [[接口]] 
	+ 接口即约定
	+ Go 的接口是隐式实现，某个类型只要实现了接口中的所有方法，就称该类型实现了某个接口
	+ `fmt.Stringer` 和 `fmt.GoStringer` 接口，用于定制对象的字符串表达形式
	+ 动态值为 `nil` 的接口值不是 `nil`

+ [[sort 包]] 
	+ `sort.Interface` 接口。只要类型实现了这个接口，就可以使用下面函数进行排序
		+ `func Sort(data Interface)`
	+ `sort` 包提供了三种已经实现了 `sort.Interface` 接口的类型
		+ `IntSlice`
		+ `Float64Slice`
		+ `StringSlice`

+ [[错误和异常]] 
	+ `errors` 接口
	+ `panic` 和 `recover`

+ [[面向对象]] 
	+ 封装：Go 的最小封装单位是 **包**。包内的标识符是否导出由其名字的首字母的大小写控制
		+ 标识符首字母大写，就可以在包外可见(导出的)
		+ 标识符首字母小写，只能在包内可见(非导出的)
	+ 继承：Go 通过结构体的匿名嵌入模拟继承，是一种组合关系
		+ 结构体嵌入表达的关系是 `has-a` 关系
		+ 面向对象中的继承表达的是 `is-a` 关系
	+ 多态：Go 通过接口类型实现多态

+ [[泛型]] 
	+ 泛型函数
	+ 泛型类型
	+ 类型约束
		+ 类型推断

---

### 第六章：时间 文件 IO 序列化 日志 

+ [[时间]]：由标准包 `time` 提供 
	+ 时区：`Location` 类型
	+ 时间：`Time` 类型
		+ 解析与格式化
			+ 模板 `010203040506pm-0700` (`01`月 `02` 号 下午`03` 点 `04` 分 `05` 秒 `06` 年 西七区)
			+ 模板 `2006-01-02 15:04:05 -0700`
		+ 时间算术运算和比较
			+ 不允许使用运算符（**Go 不支持运算符重载**），都是必须使用对应的函数
			+ `t.Add(d)`：`d` 是一个 `Duration` 类型
			+ `t.Sub(ot)`: `ot` 是 `Time` 类型，返回值是 `Duration` 类型
	+ 间隔：`Duration` 类型

+ [[文件 IO]]：标准包 `os` 为操作系统功能提供了一个与平台无关的接口，这里介绍与文件 IO 相关的接口 
	+ `File` 结构体
	+ `os.OpenFile()` `os.Open()` 和 `os.Create()` 用于打开一个文件
		+ 参数 `flag` 指定打开文件的使用
	+ `file.Close()` 方法用于关闭文件
		+ `withClose` 函数：一种类似于 Python 中 with 语句的操作
	+ `file.Read()` 和 `file.Write()` 执行 IO 操作
	+ `file.Seek()` 改变文件偏移
	+ `file.ReadAt()` 和 `file.WriteAt()` 用于指定字节偏移。它不会移动文件指针
	+ `file.Sync()` 强制文件处于同步 IO 数据完整性状态

+ [[通用 IO 接口]]：标准包 `io` 中定义了一些列的 IO 接口 
	+ `io.Reader` 和 `io.Writer` 是两个非常重要的接口

+ [[缓冲 IO]]：标准包 `bufio` 提供了 **用户空间的缓冲IO** 
	+ `bufio.Reader` 和 `bufio.Writer` 类型，用于用户空间的缓冲 IO

+ [[字节缓冲]]：标准包 `bytes` 提供了 `Buffer` 类型，实现了**大小可变的 _字节缓冲_** 
	+ `bytes` 包还提供了处理 `[]byte` 切片的实用函数，类似于 [[字符串#标准包 `strings`|标准包 strings]]
	+ `bytes.Buffer` 提供了在内存中操作的字节缓冲区，类似于文件对象
	+ `bytes.Reader` 提供了读取器，拥有读取内容

+ [[文件属性]] 
	+ `FileInfo`：文件元数据信息
	+ `FileMode`：最高 $12$ 个有效位代表文件模式位，最低的 $9$ 个有效位代表文件的 Unix 权限位

+ [[路径与目录]] 
	+ 路径操作
		+ `filepath.Join` 路径拼接
		+ `filepath.Split` 路径分割
		+ `filepath.Ext` 获取扩展名
		+ `filepath.Dir` 删除路径元素最后一个
	+ 遍历目录
		+ `filepath.Walk`：递归遍历目录，对目录的处理以回调函数提供
		+ `filepath.Walkdir`：递归遍历目录，对目录的处理以回调函数提供
		+ `os.ReadDir`：读取指定的目录
	+ 目录操作
		+ `os.UserHomeDir()` 获取用户家目录
		+ `os.Getwd()` 获取进程当前工作目录
		+ `os.Chdir()` 修改当前工作目录
		+ `os.Mkdir()` 创建目录
		+ `os.MkdirAll()` 递归创建目录
		+ `os.Remove()`：删除文件或非空目录
		+ `os.RemoveAll()`：递归删除目录
		+ `os.Rename(oldpath, newpath)`: 重命名 
	+ 存在性检测
		+ `os.IsNotExisit(err)` 目录是否存在

+ [[序列化]]  
	+ 序列化：内存中的对象按照某种 **协议** 转变为字节序列
	+ 反序列化: 字节序列按照某种 **协议** 恢复为内存中的对象
	+ 协议：解决 **对象的类型**，**对象的值**，**值的间隔** 如何存储的问题
	+ Json：字符序列化协议，序列化后得到的字节序列表示的是字符串
		+ 按照 Json 字符串中的 **不同形式** 的字符序列代表不同的 **类型** 和 **值**
		+ Go 的 `string` 类型 ==>`"..."` 代表 JS 字符串 ==> Go 的 `string` 类型 
		+  Go 的 `array` 和 `slice` 类型 ==> `[....]` 代表 JS 数组 ==>  Go 的 `slice` 类型
		+ `{....}` 代表 JS 对象 <==> Go 的 `map` 和 `struct` 类型
		+ `false` 代表 JS 布尔类型的值 `false` <==> Go 的 `bool` 类型的值 `false`
		+ `true` 代表 JS 布尔类型的值 `true` <==> Go 的 `bool` 类型的值 `true`
		+ `null` 代表JS 空类型的值 <==> Go 的字面值 `nil`
		+ Go 的 `float64` `float32` `int` `uint` 类型 ==> `xxx` 代表 JS 数值类型 ==>  Go 的 `float64` 类型
			+ `x` 代表了 `0-9` 中的一个字符
	+ MessagePack：二进制序列化协议
		+ 数据格式与 Json 类似，但是在存储时对数字、多字节字符、数组等都做了很多优化
		+ `true` `false` 采用 $1$ 个字节表示，（`0xc3` 表示 `true`，`0xc2` 表示 `false`）
		+ **定长对象**：就是 **数字** 之类的，他们天然是定长的，是用一个字节表示后面的内容是什么
		+ **不定长对象**：比如 _字符串_、_数组_、_二进制数据_，类型后面加 `1~4`个字节，用来存长度
		+ **高级数据结构**：`map` ，就是 `k-v` 结构的数据，和数组差不多，加 `1~4` 个字节表示后面有多少个项
		+ **Ext结构**：表示特定的小单元数据。也就是 **用户自定义数据结构**
	+ Base64 编码
		+ 使用了 `A-z a-z 0-9 + /` 共计 $64$ 个可打印字符编码二进制序列
		+ 编码过程：每 $3$ 字节编码为 $4$ 字符
			+ 首先，如果字节序列的长度不是 $3$ 的倍数，则最后使用 $0$ 补齐
			+ 然后，将 $3$ 个字节按照 $6$ 位一组进行划分，每组都对应了编码表的一个索引
			+ 所以，每组就对应了一个可打印字符
		+ 解码过程：每 $4$ 字符解码为 $3$ 字节
			+ 首先，查询编码表，获得每个字符对应的值(索引)
			+ 然后，每个值都只取低 $6$ 位，组合起来
			+ 最后，每 $8$ 位一组，转换为一个字节

+ [[日志]]
	+ **日志** 是指系统所指定 _对象的某些操作_ 和其 _操作结果_ 按时间有序的集合。通常记录在一个文件中，称为 **Log文件**(**日志文件**)
	+ 标准包 `log`
		+ `log` 包提供了三类输出函数，默认使用标准日志记录器，它将日志消息输出到 `os.Stderr`
		+ `log.New(out, prefix, flags)` 可以自定义一个日志记录器
	+ 第三方包 `zerolog`
		+ 全局日志记录器 `log.Logger`，可以以自定义。它是日志记录器缺省时使用的
		+ 支持日志分级处理。日志级别由高到低分别为 `panic fatal error info debug trace`。 `Nolevel` 无等级日志；`Disable` 禁用日志
			+ **全局日志等级(`gLevel)`**：控制所有记录器的最低等级
			+ **日志记录器等级(`logger.Level`)**: 控制该日志记录器上的最低日志等级
			+ **日志消息等级`mLevel`**：日志消息的等级
			+ **_重要_**: 只有当 $\text{mLevel} \ge \max{(\text{gLevel}, \text{logger.Level})}$ 这条日志才会被输出
		+ `zerolog.MultiLevelWriter` 支持将日志输出到多个地方

+ [Task Tracker by roadmap.sh](https://github.com/duyupeng36/task-tracker)
+ [Expense Tracker by roadmap.sh](https://github.com/duyupeng36/expense-tracker)

---

### 第七章：模块化 反射 加密

+ [[模块化]]  
	+ 包
		+ `init` 函数：无参数并且无返回值。用于初始化包
		+ `init` 函数的执行时间：在全局变量声明之后，`main` 函数执行之前
		+ `init` 函数的执行顺序：Go 编译器从 `main` 包开始检查其导入的所有包， 每个包中又可能导入了其他的包。由此，生产一棵树，再根据引用顺序决定编译顺序，依次编译这些包的代码
	+ 包管理
		+ Go Modules
			+ `go mod init moduleName`
			+ `go mod tidy` 对于 `go.mod` 和项目的依赖
		+ `go.mod` 中的一些指令
			+ `require` 指定依赖
			+ `replace` 替换依赖：导入本地其他项目中的包
		+ 导入第三方包
			+ `go get -u xxxx` 直接下载
			+ 修改 `go.mod`，然后执行 `go mod download`

+ [[反射]]  
	+ 所谓反射就是在程序 **运行时** 获取变量 **类型信息** 和 **值信息** 的能力
	+ `reflect.Type` 是一个接口，描述了变量的类型信息。使用 `reflect.TypeOf(i)` 获取变量 `i` 的类型 `Type`
		+ `Type` 和 `Kind` 的区别：`Type` 代表具体类型，`Kind` 代表一类类型的种类
	+ `reflect.Value` 是一个结构体，用于描述变量的值信息。使用 `reflect.ValueOf(i)` 获取变量 `i` 的 `Value`
		+ `Value` 可寻址的概念
			+  `reflect.ValueOf(&x).Elem()` 它是 **指针的解引用** 方式生成的，**指向另一个变量**，因此是可取地址的
			+ **_重要的_**：_通过 **指针** 间接地获取的 `reflect.Value` 都是 **可取地址** 的_，即使开始的是一个不可取地址的 `Value`
			+ `v := reflect.ValueOf(slice).Index(1)` 这也是可寻址的。因为 `slice[i]` 隐含了指针
	+ `value.Call(in)` 调用函数，`in` 的类型是 `[]Value`，用于给函数提供参数
		+ 会返回一个 `[]Value`，表示函数的返回值
	+ `reflect.New(type)` 可以创建 `type` 类型的指针

+ [[加密与解密]]  
	+ 对称加密：DES 3DES AES
		+ 分组模式
			+ ECB：电子密码本模式。不建议使用
			+ CBC：密码分组链接模式。明文需要填充到分组大小的整数被，通常使用能够 PKCS7 填充算法。还需要一个初始化向量
			+ CFB：密文反馈模式。明文不需要填充。需要一个初始化向量
			+ OFB：输出反馈模式。明文不需要填充。需要一个初始化向量
			+ CTR：计数器模式。支持并行计算，不需要填充明文。需要一个初始化向量
	+ 非对称加密: RSA
		+ RSA：安全性基于大整数的质因数分解非常困难

### 第八章：基本数据结构

+ [[线性表]] 
	+ 单链表和双链表

+ [[栈和队列]]  
	+ 栈：插入和删除被限制在线性表的同一端进行
		+ 顺序实现
		+ 链式实现
	+ 队列：插入和删除分别在线性表的两端进行
		+ 顺序实现: 环形队列
		+ 链式实现

+ [[数据结构与算法/散列表|散列表]] 
	+ 散列函数
	+ 拉链法
	+ 开放定址法

### 第九章：基本算法

+ [[算法复杂度]]  
	+ **大 O 记法**：如果存在常数 $c \gt 0$ 和 $n_0$，当 $N \ge n_0$ 时 $T(N) \le cf(N)$，则记为 $T(N) = O(f(N))$

+ [[排序]]  
	+ **冒泡排序($O(N^2)$)**：比较相邻两元素，如果顺序错误则交换。
	+ **插入排序($O(N^2)$)**：将序列分为有序区和无序区，依次选择无序区元素并将其插入到有序区的正确位置上
	+ 选**择排序($O(N^2)$)**：将序列分为有序区和无序区，有序区最开始为空。依次从无序区选择最小元素放在有序区的最后
	+ **希尔排序($O(N^{1.43})$)**：使用增量序列将序列划分为多个子序列，每个子序列都执行依次插入排序
	+ **归并排序($O(N \log N)$)**：对归将序列拆分为两部分，直到子序列长度为 $1$。然后两两合并，此时保证合并后的序列是排序的
	+ **快速排序($O(N \log N)$)**：选择一个主元，将序列划分两个子序列。然后递归处理主元两边的子序列
	+ **堆排序**：在数据结构 [[堆]] 中介绍

+ [[查找]]  
	+ 线性查找：从序列的第一个元素开始和目标元素比较
	+ 二分查找：序列是排序的，每次都与中间元素比较，然后确定目标元素所在的半区
	+ 更多查找算法在 [[树与二叉树]] 中介绍

### 第十章：树与堆

+ [[树与二叉树]]  
	+ 树：节点的集合，其中一个节点成为根。一般树采用 **孩子-兄弟** 方式实现
	+ 二叉树：是一棵树，每个节点至多有 $2$ 棵子树。子树是有顺序的，即便只有一棵子树，也要区分左右
	+ 满二叉树：叶子节点只在最后一层出现
	+ 完全二叉树：叶子节点只在最后两层出现，并且叶子节点必须先安排在左子节点
	+ 二叉树顺序存储：按照从上到下，从左到右依次将节点存储在一片连续的区域上。如果某个节点缺失，则将在连续的存储空间中空出来。一般只有 **完全二叉树** 才采用顺序存储
	+ 一般二叉树通常采用链式存储实现
	+ 二叉树的遍历：深度优先和广度优先
		+ 三种顺序的遍历都是深度优先
		+ 广度优先：层次遍历，一层一层的遍历

+ [[二叉查找树]]  
	+ 二叉查找树也称二叉排序树
	+ 二叉查找树是一颗二叉树（结构性），但是要求每个节点的左子节点存储的关键字小于当前节点；右子节点存储的关键字大于当前节点（有序性）
	+ 二叉查找树的插入非常简单，只需递归插入即可；二叉查找树的删除可以将删除节点的关键使用起右子树的最小值替代，然后递归去删除其右子树的最小值
		+ **右子树中的最小值节点不可能有左子树**，所以删除它更容易

+ [[AVL 树]]  
	+ AVL 树：带有平衡条件的二叉排序树。解决了如果查询关键字是排序后，二叉查找树退化为链表的缺陷
	+ 宽松的平衡条件：某个节点的左子树和右子树的高度差 $1$
		+ **重要**：空子树的高度定义为 $-1$
	+ 插入操作会引起四种不平衡的情形。理论上是两种
		+ 某个节点的左子节点的左子树上插入(左-左情形)
			+ 解决方案：右旋
		+ 某个节点的左子节点的右子树上插入(左-右情形)
			+ 解决方案：左旋-右旋
		+ 某个节点的右子节点的左子树上插入(右-左情形)
			+ 解决方案：右旋-左旋
		+ 某个节点的右子节点的右子树上插入(右-右情形)
			+ 解决方案：左旋

+ [[堆]]  
	+ 结构：一个堆是顺序存储的完全二叉树
	+ 堆序
		+ 小根堆：根节点中的关键字小于其所有后裔
		+ 大根堆：根节点中的关键字大于其所有后裔
	+ 堆排序
		+ 基于二叉堆的排序算法：将序列分为前后两个部分，前一部分为无序区，后一部分为有序区
		+ 开始有序区为空。首先，将无序区调整为大根堆；然后，将最后一个元素与根元素交换；堆中元素减小 $1$，继续调整堆成为大根堆

+ [[B 树]]  
	+ B 树也是一种查找树，将所有数据存储在叶子，内部节点存储下一个树叶发现的最小值
	+ 能够以 $O(M \log_M N) = O((M/ \log M) \log N)$ 时间执行插入和删除

+ [[红黑树]]
	+ 
### 第十一章：图

+ [[图]]

+ [[最短路径]]

+ [[不相交集]]

+ [[最小生成树]]

### 第十二章：并发与网络

由于 Go 语言将并发模型做了非常好的封装。并没有提供进程、线程的简单易用的接口，从而导致我们使用 Go 创建进程和线程的难度非常大。我们在后续的演示中，使用 C 和 Linux 系统调用进行

+ [[进程]]  
	+ 程序不是进程。非正式的说，当程序加载到内存之后，才能称为进程
	+ 进程本质上就是 **用户内存空间** 和 **内核数据结构** 的集合。内核数据结构 PCB（进程控制块）才是内核看见的进程
	+ 需要掌握进程的 **虚拟内存结构**
		+ ![[Drawing 2024-08-01 08.35.36.excalidraw|900]]
	+ 了解 PCB 中保持的信息
		+ **进程标识(PID)**：程序中控制进程使用的标识符，一个整数
		+ **虚拟内存表(内存管理信息)**：系统使用的内存系统信息。这类信息可以包括 _基地址_ 和 _界限寄存器的值_、_页表_ 或 _段表_
		+ **进程资源使用及其限制**
		+ **当前工作目录**
		+ **信号传递及其处理的信息**
		+ **程序计数器**：指向进程下一条要执行的指令
		+ **CPU 寄存器**：进程使用的寄存器中的指
		+ **CPU 调度信息(进程状态)**：包括进程优先级、调度队列的指针及其他调度参数
		+ **程序的记账**：CPU时间、实际时间、进程数量等
		+ **IO状态**：分配给进程的 _IO 设备列表_ 和 _打开文件列表_
	- 掌握进程的 $5$ 中状态，及其转换
		+ ![[Drawing 2024-08-01 09.28.24.excalidraw|900]]
	+ 了解进程的调度策略
		+ 先来先服务(FCFS)：先进入就绪状态的进程先被调度
		+ 最短作业优先(SJF)：就绪进程中执行时间最短的进程先被调度
		+ 最短剩余时间优先(SRTF)：它是 SJF 的抢占版本
		+ 轮转调度(RR)：为进程分配固定的时间片，每次进程最长的运行时间就是时间片的大小
		+ 优先级调度：为进程绑定一个优先级，优先级高的进程优先被调度
		+ 多级队列：进程被放在不同的继续队列中，每个队列都有自己的调度算法。这些就绪队列也可以有自己的调度算法
		+ 多级反馈队列：可以动态改变进程所处的就绪队列
	+ 创建进程
		+ 在 Linux 上使用系统调用 `fork()` 创建一个与调用进程一模一样的子进程。子进程与父进程一同执行
	+ 进程间通信
		+ 同一个虚拟地址在不同的进程中映射的物理内存可能不同，因此进程之间通过虚拟地址交换数据是不可能的
		+ 进程间通信需要内核提供支持，进程将数据交给内核，内核在将数据交给另外的进程

+ [[线程]]   
	+ 线程是和进程类似，只是同一个进程中的线程共享了某些进程属性罢了
	+ 不要被某些书本误导：进程是资源分配单位，线程是内核调度单元。
	+ **进程和线程都是内核的调度单元，只是进程之间不共享任何东西，线程可以共享进程持有的资源**

+ [[网络]]  
	+ TCP/IP 四层模型
	+ 每层使用的协议和协议的数据包是如何封包的
	+ TCP 三次握手 
		+ 客户端向服务端发送 SYN 报文段，并提供客户端的初始序列号(`ISN(c)`)
		+ 服务端接收到客户端的 SYN 报文段之后，发送自己的 SYN 报文段作为响应，同时提供服务端的初始序列号(`ISN(s)`)。与此同时，为了确认客户端的 SYN，服务端还会将客户端的序列号加 $1$ 作为 确认号(ACK号)
		+ 客户端接收到服务端的响应之后，向服务端发送 ACK 报文段。同时，将自己的序列号加 $1$，并且将服务端的序列号加 $1$ 作为 ACK 号
	+ TCP 四次挥手 
		+ 首先，连接的 **主动关闭者** 发送一个 **FIN 报文段** 指明接收者希望看到自己的 **_当前序列号_ (接收者希望看到的) K**。 FIN 段还包含了一个 `ACK` 段用于确认对方最近一次发来的数据 L
		+ 然后，连接的 **被动关闭者** 将 `K + 1` 作为响应的 `ACK` 值，表明它已成功接收到主动关闭者发送的 `FIN`
		+ 此时，**上层应用程序会被告知连接的另一端已经提出关闭的请求**。此时，导致应用程序发起自己的关闭操作；接着，**被动关闭者的身份将转变为主动关闭者**，发送自己的 `FIN` 段，该段的序号为 `L`
		+ 最后，为了完成连接的关闭，最后发送的报文段还包含一个 `ACK` 用于确认上一个 `FIN`。如果 `FIN` 出现丢失的情况，发送方还将重新传输直到接收到一个 `ACK` 确认为止
	+ HTTP 报文格式

+ [[SOCKET]]  
	+ SOCKET 是封装了各种网络通信的接口
	+ 使用 SOCKET 编写能够进行网络通信的程序，对于服务端需要依次完成
		+ 创建套接字
		+ 创建地址结构
		+ 为套接字绑定地址
		+ 监听套接字
		+ 等待客户端连接并接收客户端连接
		+ 接收客户端发送过来的消息
		+ 处理消息
		+ 向客户端返回响应
		+ 关闭套接字
	+ 客户端需要一次完成
		+ 创建套接字
		+ 创建连接的地址结构
		+ 对地址发起连接请求(三次握手与服务端建立连接)
		+ 向服务端发送消息
		+ 等待服务端响应
		+ 处理服务端的响应

+ [[网络 IO 模型]]  
	+ 非阻塞 IO：IO无法立即完成时，IO操作不阻塞
	+ IO 多路复用：事件驱动 IO，由操作系统监管一系列的文件描述符，当文件描述符状态发生改变时，立即返回（会将线程阻塞）

+ [[协程]]  
	+ 理解 **协程** 的本质：**暂停函数的执行**，同时 **让出控制给其他函数**

+ [[Groutine]]  
	+ `go` 关键字和很方便的将 Go 函数包装为 Groutine

+ [[Go 协程调度]]  
	+ 掌握 Go 程序是如何启动的
	+ 掌握 Groutine 的创建与退出
	+ 掌握 Groutine 的调度 `runtiem.schedule()` 函数

+ [[通道]]  
	+ 通道的数据结构：环形队列
	+ 通道支持三种操作：send recv close
	+ 对 empty 通道执行 recv 操作会阻塞；同样对一个 full 通道执行 send 也会阻塞
	+ close 操作只允许发送者进行关闭。**已关闭的通道上执行 send 会 panic**

+ [[同步]]  
	+ 等待组(`sync.WaitGroup`)：让 Main Goroutine 等待其他 Goroutine 结束
	+ 互斥锁(`sync.Mutex`)：同步
	+ 读写锁(`sync.RWMutex`)：同步写，并发读
	+ 掌握 **并发非阻塞缓存** 的实现思路

### 第十四章：网络编程

+ [[Go TCP]] 
	+ 掌握如何创建 TCP 服务端和TCP 客户端
	+ 掌握解决 TCP 粘包的方案

+ [[Go UDP]]  
	
### 第十五章：SQL数据库

+ [[PostgreSQL介绍]]  
	+ 介绍了 PostgreSQL，并在 Windows 上进行了安装
	+ 加载了官方提供了学习示例数据库

+ [[关系]]  

+ [[查询数据库]]  
	+ 最基本的查询语句: `SELECT ... FROM ...`
	+ 列别名: `column_name AS alias_name`
	+ 排序：`SELECT ... FROM ... ORDER BY ....`
	+ 去重：`SELECT DISTINCT .... FROM ...`

+ [[过滤数据]]  
	+ 基本的过滤：`SELECT .... FROM .... WHERE .... ORDER BY ....`
	+ 构建 `WHERE` 条件部分需要比较运算符和逻辑运算符
		+ 比较运算符: `>` `>=` `<` `<=` `<>, !=` 
		+ 逻辑运算符: `AND` `OR` `NOT`
	+ 分页：`LIMIT row_count OFFSET row_to_skip` 和 `OFFSET row_to_skip FETCH row_count`
		+ 跳过 `row_to_skip` 行，然后选择 `row_count` 行数据
		+ 建议使用 `FETCH` 子句，这是 SQL 标准
	+ 其他过滤运算符
		+ `IN` 和 `NOT IN`：筛选某些枚举值
		+ `LIKE` 和 `NOT LIKE` 以及 `LIKE ... ESCAP ...` 和 `NOT LIKE ... ESCAP ...`：模糊查询
		+ `BETWEEN ... AND ...` 和 `NOT BETWEEN ... AND ...`：在某个范围内筛选
		+ `IS NULL` 和 `IS NOT NULL`： 筛选 `NULL` 值

+ [[连接多张表]]  
	+ INNER JOIN
	+ LEFT JOIN：左表为基准；右表中的不匹配行使用 NULL 填充
	+ RIGHT JOIN：右表为基准；左表中的不匹配行使用 NULL 填充
	+ SELF-JOIN：通过表别名，使用同一张表建立连接
	+ FULL OUTER JOIN：LEFT JOIN 和 RIGHT JOIN 结果的并集
	+ NATURAL JOIN：默认使用两张表中相同的列名建立连接，默认建立 INNER JOIN

+ [[分组]]  
	+ GROUP BY：SELECT 中出现的非聚合字段，应该都在 GROUP BY 中出现
	+ HAVING：过滤分组
	+ 聚合函数
		+ MAX()
		+ MIN()
		+ COUNT()
		+ SUM()
		+ AVG()
	+ 分组集
		+ GROUPING SETS：自行指定分组集
		+ CUBE：生成所有的分组集
		+ ROLLUP：生成层次分组集

+ [[集合运算]]  
	+ 对两个 SELECT 语句的结果集进行集合操作
	+ UNION：并集
	+ INTERSECT：交集
	+ EXCEPT：差集

+ [[子查询]]  
	+ WHERE 中的子查询
	+ HAVING 中的子查询
	+ 当子查询返回多个值时，可以使用的比较操作符
		+ IN
		+ ALL
		+ ANY

+ [[相关子查询]]  
	+ 如果 **子查询的执行依赖于外部查询**，通常情况下都是因为 **子查询中的表用到了外部的表，并进行了条件关联**
	+ FROM 中的子查询
	+ ORDER BY 中的子查询
	+ EXISTS 与 NOT EXISTS 关键字

+ [[子查询练习]]

+ [[公用表表达式]]  

+ [[库管理]]  

+ [[表管理]]  
	+ 创建表
		+ `CREATE TABLE`
		+ `SELECT ... INTO ...`
		+ `CREATE TABLE AS query`
		+ `SERIAL` 伪类型，产生一个自增序列
		+ `SEQUENCE` 序列，使用 `CREATE SEQUENCE` 创建
		+ `GENERATED AS IDENTITY` 标识列
		+ `GENERATED AS ALWAYS | SET DEFAULT` 生成列，根据表达式生成值
	+ 修改表
		+ 修改表名
		+ 添加列
		+ 删除列
		+ 更改列的类型
		+ 重命名列
		+ 添加列约束

+ [[约束]]   
	+ 主键 ：唯一标识一行的列或列组
	+ 外键 ：引用其他表中的一列或列组
		+ 插入：父表可以随便插入，子表的 **外键字段的值必须要在父表中存在**
		+ 更新和删除：PostgreSQL 支持以下操作
			+ `SET NULL`
			+ `SET DEFAULT`
			+ `RESTRICT`
			+ `NO ACTION`
			+ `CASCADE`
	+ CHECK ：检查是否满足某个条件
	+ UNIQUE ：唯一
	+ NOT NULL：非空
	+ DEFAULT：默认约束

+ [[数据类型]]  

+ [[修改数据]]  
	+ 插入
	+ 更新
	+ 删除

+ [[事务]]  
	+ A: 原子性，事务中的操作必须完全成功，或者完全不成功
	+ C：一致性，写入数据库的中数据有效且符合预定义规则
	+ I：隔离性，事务之间是隔离的
	+ D：持久性，已提交的数据无论如何都在数据库中

+ [[psql命令]]  

+ [[条件表达式]]  
	+ `CASE ... WHEN ... THEN`

+ [[PL-pgSQL]]  
	+ SQL 编程

+ [[触发器]]

+ [[索引]]

+ [[视图]]

+ [[Go SQL]] 
	+ 熟悉 `database/sql` 接口的使用

+ [[GO GORM]]  
	+ 连接数据库
	+ 模型定义
	+ 查询
		+ `Take` `First` `Last` `Find`
		+ `Scan` `Rows`  这两个接口和 `database/sql` 提供的接口非常相似
			+ `Rows` 类似于 `sql.Query()` 需要按行进行 `Scan`
		+ `Where` 条件
		+ `Group & Having` 
		+ `Distinct`
		+ `Rows & Scan`
	+ 关系
		+ 一对多：`Has Many` 和 `Belongs To`
		+ 一对一: `Has One`
		+ 多对多: `Many To Many`
	+ 关联模式
		+ 自动创建更新关联
		+ 关联的
			+ `Find()`
			+ `Append()`
			+ `Replace()`
			+ `Delete()`
			+ `Clear()`
		+ 预加载
			+ `Preload()`
			+ `Joins()`\

### 第十六章：NoSQL 数据库

+ [[MongoDB]]  查看 [MongoDB 手册](https://www.mongodb.com/zh-cn/docs/manual/) 获取详细信息
	+ 安装
	+ CAP 定理和 BASE 定理：分布式系统可用性和一致性要求
		+ CAP：分布式系统无法同时满足 **一致性(Consistency)** **可用性(Availability)** **分区容错性(Partition tolerance)** 
		+ BASE：是 NoSQL 数据库通常 **对可用性及一致性的弱要求原则**
			+ **B**asically **A**vailable --**_基本可用_**
			+ **S**oft-state --**_软状态/柔性事务_**
			+ **E**ventually Consistency -- **最终一致性**
	+ 文档插入
		+  `db.collectionName.insertOne()`
		+ `db.collectionName.insertMany()`
	+ 查询文档
		+ `db.connectionName.find({ 字段: {条件: 值}) })`
	+ 更新文档
		+ `db.collectionName.updateOne()`
		+ `db.collectionName.updateMany()`
	+ 删除文档
		+ `db.collectionName.deleteMany()`
		+ `db.collection.deleteOne()`

+ [[Go Mongo]]   查看 [MongoDB 驱动](https://www.mongodb.com/zh-cn/docs/drivers/) 获取详细信息

+ [[Redis]]

+ [[Go Redis]]

### 第十七章：HTTP 编程

+ [[Go HTTP 客户端]] 
	+ URL 的解析
	+ 如何发起 HTTP 请求
	+ 如何处理响应数据
	+ 如何定制请求
		+ 设置 request header
		+ 设置 query 参数
		+ 设置 Body 数据：json，表单上数据，文件上传
		+ 设置 cookie
		+ 重定向
		+ 设置超时时间
		+ 设置代理
+ [[grequests]]

+ [GitHub User Activity](https://github.com/duyupeng36/github-user-activity)

+ [[Go HTTP 服务端]]  
	+ `ServeHTTP(ResponseWriter, *Request)` 是 `http.Handler` 接口需要实现的方法。主要就是用于匹配 URL 和模式，并调用对应的处理函数

## 项目

+ [[单元测试]]  
	+ 程序写好就能运行，那是属于运气好
	+ `TestXxxx(t *testing.T)` 单元测试函数
	+ `BenchmarkXxxx(b *testing.B)` 基准测试函数
	+ `ExampleXxxx()` 示例函数

+ [[软件研发流程]]

### Web 项目：vblog

+ [[项目搭建]]
	+ 产品原型与产品架构
	+ 两种业务代码组织风格：MVC 和 DDD
		+ MVC 传统的业务分层模型
			+ M：Models，定义业务数据模型
			+ V：Views，定义业务数据展示样式
			+ C：Controllers，控制 M 和 V，让 M 和 V 解耦
		+ DDD 业务分区（项目采用的代码组织风格）
			+ 每个分区就是一个业务单元，称为 **领域**
			+ 领域内有自己的管理的数据，对自己管理的数据有着权威。其他领域只能通过该领域提供的领域接口进行数据访问
	+ RESTful API
		+ REST(Representational State Transfer)：表征 **状态** 转移
		+ 完整的讲 REST 说的是 **资源的状态转移**。所谓资源，就是网络上的实体，可能是文本、音视频等等
			+ 资源总是以一定的格式来表现自己
		+ RESTful API 通过 **URI 代表资源**，**HTTP 请求方法代表资源状态的转移**
		+ RESTful API 只是暴露业务接口的能力一种手段
	+ 项目骨架：开发从上到下
		+ 项目的配置管理：`config` 包，负责处理程序的加载
		+ 业务模块：`apps` 包 
		+ 项目文档(`docs`)
		+ 项目的接口(`protocal` 包)：协议服务器，监听对应的端口
		+ 项目的 CLI (`cmd` 包)
		+ 项目的入口文件：`main.go`
		+ 配置文件目录(`etc`)：存储配置文件

+ [[配置管理]]

+  [项目后端代码](https://github.com/duyupeng36/vblog)

+ [[JavaScript]]

+ [[HTML]]

+ [[CSS]]

+ [[DOM 和 AJAX]]

+ [[Vue3 入门]]

+ [项目前端代码](https://github.com/duyupeng36/vblog/tree/master/ui)

### 微服务项目：devcloud-mini

+ 

+ [[RPC]]

+ [[GRPC]]







